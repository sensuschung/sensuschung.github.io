<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>monad概览</title>
      <link href="/2024/06/03/monad%E6%A6%82%E8%A7%88/"/>
      <url>/2024/06/03/monad%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li><code>m</code>类型构造子</li><li><code>return :: a -&gt; M a</code>：（也叫做<code>unit</code>），接受一个类型<code>a</code>的值，把它们包装成使用这个类型构造子建造的类型<code>m a</code>的“单子值”</li><li><code>bind :: (M a) -&gt; (a -&gt; M b) -&gt; (M b)</code> ：也可写作 <code>&gt;&gt;=</code>，接受一个在类型<code>a</code>上的函数<code>f</code>，并应用<code>f</code>于去包装的值<code>a</code>，转变单体值<code>m a</code>。</li></ul><p>通过以上元素，复合出一个函数调用的序列，在一个表达式中通过一些<strong>bind算子</strong>把它们链接起来。</p><p>每个函数调用<u>转变</u>它的输入普通类型值，而bind算子<u>处理返回的单子值</u>，它被填入到序列中下一个步骤。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><div class="note primary modern"><p>案例：maybe</p></div><ul><li>需要显示定义函数的返回状态：<code>Just ⌑result⌑</code>, or <code>Nothing</code></li></ul><p>案例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(x: Decimal, y: Decimal) <span class="punctuation">-&gt;</span> Maybe&lt;Decimal&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> y == <span class="number">0</span> &#123; <span class="keyword">return</span> Nothing &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="title function_ invoke__">Just</span>(x / y) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// divide(1.0, 4.0) -&gt; returns Just(0.25)</span></span><br><span class="line"><span class="comment">// divide(3.0, 0.0) -&gt; returns Nothing</span></span><br></pre></td></tr></table></figure><ul><li>检查<code>Maybe</code>算子返回的值(上)或使用类型匹配（下）</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">m_x</span> = <span class="title function_ invoke__">divide</span>(<span class="number">3.14</span>, <span class="number">0.0</span>); <span class="comment">// see divide function above</span></span><br><span class="line"><span class="comment">// The if statement extracts x from m_x if m_x is the Just variant of Maybe</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Just</span>(x) = m_x &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;answer: &quot;</span>, x)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;division failed, divide by zero error...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">divide</span>(<span class="number">3.0</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="keyword">match</span> result &#123;</span><br><span class="line">    <span class="title function_ invoke__">Just</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Answer: &quot;</span>, x),</span><br><span class="line">    Nothing =&gt; <span class="built_in">println!</span>(<span class="string">&quot;division failed; we&#x27;ll get &#x27;em next time.&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多输入monad，单输出monad</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">chainable_division</span>(maybe_x: Maybe&lt;Decimal&gt;, maybe_y: Maybe&lt;Decimal&gt;) <span class="punctuation">-&gt;</span> Maybe&lt;Decimal&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> (maybe_x, maybe_y) &#123;</span><br><span class="line">        (<span class="title function_ invoke__">Just</span>(x), <span class="title function_ invoke__">Just</span>(y)) =&gt; &#123; <span class="comment">// If both inputs are Just, check for division by zero and divide accordingly</span></span><br><span class="line">            <span class="keyword">if</span> y == <span class="number">0</span> &#123; <span class="keyword">return</span> Nothing &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="title function_ invoke__">Just</span>(x / y) &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> Nothing <span class="comment">// Otherwise return Nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">chainable_division</span>(<span class="title function_ invoke__">chainable_division</span>(<span class="title function_ invoke__">Just</span>(<span class="number">2.0</span>), <span class="title function_ invoke__">Just</span>(<span class="number">0.0</span>)), <span class="title function_ invoke__">Just</span>(<span class="number">1.0</span>)); <span class="comment">// inside chainable_division fails, outside chainable_division returns Nothing</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>&gt;&gt;=</code>来传递多次匿名函数；多参数处理</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">halve</span> :: <span class="type">Int</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">halve</span> x</span><br><span class="line">  | even x = <span class="type">Just</span> (x `div` <span class="number">2</span>)</span><br><span class="line">  | odd x  = <span class="type">Nothing</span></span><br><span class="line"> <span class="comment">-- This code halves x twice. it evaluates to Nothing if x is not a multiple of 4</span></span><br><span class="line"><span class="title">halve</span> x &gt;&gt;= halve</span><br></pre></td></tr></table></figure><blockquote><p>x >>= y即把x传递给函数y获得返回值</p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">chainable_division</span>(mx,my) =   mx &gt;&gt;=  ( λx -&gt;   my &gt;&gt;= (λy -&gt; <span class="type">Just</span> (x / y))   )</span><br></pre></td></tr></table></figure><blockquote><p>在此处的$\lambda$表示匿名函数</p></blockquote><p>在上面的案例中，有以下几种类型：</p><ul><li><em>Monadic Type</em>：<code>Maybe</code></li><li><em>Unit operation</em>（类型转换）：<code>Just(x)</code></li><li><em>Bind operation</em>（组合子）： <code>&gt;&gt;=</code> or <code>.flatMap()</code></li></ul><h1 id="标准定义"><a href="#标准定义" class="headerlink" title="标准定义"></a>标准定义</h1><h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><ul><li><p><strong>A <a href="https://en.wikipedia.org/wiki/Type_constructor">type constructor</a></strong> <em>M</em> that builds up a <strong>monadic type</strong> <code>M T</code></p></li><li><p><strong>type converter</strong>常被叫做 <strong>unit</strong> or <strong>return</strong>，用于将一个对象<code>x</code>嵌入到单子中，<code>unit(x) :: T -&gt; M T</code></p></li><li><p><strong>combinator</strong> 典型的叫做<strong>bind</strong>，并表示为中缀算子<code>&gt;&gt;=</code>，去<u>包装</u>一个单体变量，接着把它插入到一个单体函数/表达式之中，结果为一个新的单体值：</p></li><li><code>(&gt;&gt;=) : (M T, T → M U) → M U</code>so if <code>mx : M T</code> and <code>f : T → M U</code>, then <code>(mx &gt;&gt;= f) : M U</code></li></ul><h2 id="遵循定律"><a href="#遵循定律" class="headerlink" title="遵循定律"></a>遵循定律</h2><ul><li>unit是bind的左单比特 <code>unit(x) &gt;&gt;= f</code> <strong>↔</strong> <code>f(x)</code></li><li>unit是bind的右单比特 <code>ma &gt;&gt;= unit</code> <strong>↔</strong> <code>ma</code></li></ul><blockquote><p>此处左单比特、右单比特即单位元，identity</p></blockquote><ul><li>bind符合结合律 <code>ma &gt;&gt;= λx → (f(x) &gt;&gt;= g)</code> <strong>↔</strong> <code>(ma &gt;&gt;= f) &gt;&gt;= g</code></li></ul><blockquote><p>单子构成在函子（functor）范畴上的<a href="https://zh.wikipedia.org/wiki/%E5%B9%BA%E5%8D%8A%E7%BE%A4">幺半群</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
          <category> functional programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> function programming </tag>
            
            <tag> monad </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIS2336</title>
      <link href="/2024/06/02/NIS2336/"/>
      <url>/2024/06/02/NIS2336/</url>
      
        <content type="html"><![CDATA[<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>[ ] 翻译程序</li><li>[ ] 编译程序</li><li>[ ] 编译的两大/三大阶段及区别（编译阶段生成的目标程序）</li><li><p>[ ] 解释程序和编译程序的主要区别</p></li><li><p>[ ] 编译的六个阶段、前端和后端</p></li><li>[ ] 词法分析：源程序、字符串、扫描分解、单词/单词符号/符号</li><li>[ ] 语法分析：单词符号串、语法规则、识别语法单位、检查</li><li>[ ] 语义分析、中间代码生成：语法单位、静态语义省查、分析含义、另一种语言描述（什么语言？）</li><li>[ ] 代码优化：对（）进行（）改造或变换，高效，主要包括（）和（）</li><li>[ ] 目标代码生成：将中间代码变换成（）或（）或（）</li><li>[ ] 在<strong>每个</strong>过程中，涉及表格管理和错误处理：表格的构造、查找、修改、存取</li></ul><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/study/NIS2334/image-20240530102430879.png" alt="编译流程" style="zoom: 50%;" /></p><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><ul><li>[ ] 上面的图中的流程是逻辑关系吗？是执行时间上的先后关系吗？可按照不同的执行流程来组织吗？<ul><li>[ ] 相关：一遍扫描?多遍扫描？开始和结束？优缺点？</li></ul></li><li>[ ] 编译程序：复杂系统程序</li></ul><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><h2 id="字母表和符号串"><a href="#字母表和符号串" class="headerlink" title="字母表和符号串"></a>字母表和符号串</h2><ul><li>[ ] 字母表：含义、个数、类型</li><li>[ ] 符号/字符</li><li>[ ] 符号串：有穷、特定、空</li><li>[ ] 运算：符号串（连接、幂运算）集合（乘积、闭包、正闭包）</li></ul><h2 id="文法和语言"><a href="#文法和语言" class="headerlink" title="文法和语言"></a>文法和语言</h2><ul><li>[ ] 形式语言、描述方法（枚举、文法）</li><li>[ ] 规则：终结符与非终结符</li><li>[ ] 文法：四元组、字汇表、关键、候选式与识别符号</li><li>[ ] </li></ul><h2 id="判断-1"><a href="#判断-1" class="headerlink" title="判断"></a>判断</h2><ul><li>[ ] 形式语言考虑语义。</li></ul><h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><h3 id="文法的设计"><a href="#文法的设计" class="headerlink" title="文法的设计"></a>文法的设计</h3><ol><li><p>根据字母表设计文法</p><blockquote><p>相同的幂必须合并在一起</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
          <category> class </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> 2023-2024Spring </tag>
            
            <tag> compiling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIS2334</title>
      <link href="/2024/06/02/NIS2334/"/>
      <url>/2024/06/02/NIS2334/</url>
      
        <content type="html"><![CDATA[<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="磁盘结构和调度"><a href="#磁盘结构和调度" class="headerlink" title="磁盘结构和调度"></a>磁盘结构和调度</h2><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><ul><li>控制器通过移动臂移动磁头读写磁道上的数据。<strong>每面</strong>都有独立的磁头</li><li>柱面: 所有盘片上的<strong>相同磁道</strong>组成柱面</li></ul><h3 id="磁盘时延"><a href="#磁盘时延" class="headerlink" title="磁盘时延"></a><font color="#CC0000">磁盘时延</font></h3><details>    <summary>具体计算</summary>    <img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/study/NIS2336/image-20240531151357537.png" alt="1"></details><ul><li><p>磁道优化</p><details>    <summary>优化方案</summary>    <ul>        <li>所有磁道上的BPI 相同(“固定位密度”)</li>        <li>磁盘容量更大</li>        <li>越靠外圈的磁道包含的扇区越多</li>        <li>磁盘转速固定，外磁道的速度比内磁道</li>    </ul></details></li></ul><h4 id="硬盘的使用"><a href="#硬盘的使用" class="headerlink" title="硬盘的使用"></a>硬盘的使用</h4><ul><li>硬盘必须分区</li><li>分区需用<u>某种文件系统</u>进行格式化</li><li>在某些情况下，可以用快速格式化取代完全格式化</li><li>为什么需要多分区</li><li><p>磁盘分布</p><ul><li>MBR（位置）、4个主分区、多个逻辑分区</li></ul></li></ul><h3 id="减少时延的方法："><a href="#减少时延的方法：" class="headerlink" title="减少时延的方法："></a>减少时延的方法：</h3><blockquote><p>缓存/</p><p>使用RAM磁盘/</p><p>RAID/</p><p>调度算法(读写头调度-&gt;调动磁头、元信息布置-&gt;怎么储存布置文件块)</p></blockquote><h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><ul><li><details>   <summary>关于高速缓存</summary>   <img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/study/NIS2336/20240531153644.png" alt="none"></details></li></ul><h4 id="替换策略："><a href="#替换策略：" class="headerlink" title="替换策略："></a><font color="#CC0000">替换策略</font>：</h4><ul><li>LRU</li><li>LFU</li><li>基于频率的替换算法<ul><li>优点：弱化集中访问对计数器的影响</li><li>具体实现：栈，计数器，新老两个区</li><li><img src="C:/Users/Windows11/AppData/Roaming/Typora/typora-user-images/image-20240603232956523.png" alt="image-20240603232956523" style="zoom:50%;" /></li><li>存在问题：新加入的块，如果很<u>快进入老区</u>，则没有竞争力，将很快被淘汰。</li></ul></li></ul><h4 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a><font color="#CC0000">磁盘调度</font></h4><ul><li>作用<ul><li>提高有效的<strong>数据吞吐率</strong></li><li>减少请求的<strong>平均等待时间</strong></li></ul></li><li>总结图<ul><li><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406032354849.png" alt="image-20240603235447821" style="zoom:80%;" /></li></ul></li><li><font color="red"> 常用调度策略</font></li><li><strong>FCFS</strong><ul><li>按请求的<u>时间顺序</u>，依次进行服务</li><li><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406032338650.png" alt="image-20240603233837629" style="zoom:80%;" /></li><li>优点：<ul><li>实现简单</li><li>有大量进程竞争时，在性能上接近于<strong>随机调度</strong></li></ul></li><li>缺点<ul><li><strong>寻道时间长</strong>，磁头<u>移动幅度大</u></li></ul></li><li>适合<strong>较轻负载</strong>的系统</li></ul></li><li><strong>SSTF最短寻道时间优先</strong><ul><li>优先响应寻道时间最短的请求</li><li><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406032343619.png" alt="image-20240603234311601" style="zoom:80%;" /></li><li>优点<ul><li><strong>寻道时间</strong>较短，<strong>服务效率</strong>较高，服务<strong>平均等待时间</strong>较短</li><li>提供比<u>FIFO</u>更高的效率</li></ul></li><li>缺点<ul><li><strong>公平性</strong>差，可能会出现服务请求长期得不到服务，甚至饿死</li><li><u>寻道时间</u>并不能真正实现最优。</li></ul></li><li>适合<strong>中度负载</strong>的系统</li></ul></li><li><strong>SCAN（电梯）算法</strong><ul><li>磁头<u>从一端出发向另一端移动</u>，移动过程中，发现有请求<u>对应磁头下的磁道</u>，就对该请求提供服务。到另一端后，开始反向移动，遇到请求进行服务</li><li><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406032347031.png" alt="image-20240603234757011" style="zoom:80%;" /></li><li>缺点：<ul><li>每个请求的等待时间不均匀，且<strong>平均等待时间</strong>长</li></ul></li><li>优化<ul><li><font color="blue">磁头并不是每次扫描都移动到最远的磁道上</font>，一旦在当前方向上前面没有请求，就开始反向移动。</li></ul></li><li>比较适合磁盘<strong>负载较重</strong>的系统</li></ul></li><li><strong>C-SCAN</strong><ul><li>类似电梯算法。但需要<strong>从零道开始</strong>。</li><li>磁头移动方向单一（从内到外）</li></ul></li><li>PRI进程优先级</li><li>LIFO（后进先出）<ul><li>局部性最好，资源利用率最高（等待时间少、缓存命中高）</li></ul></li><li>N-step-scan<ul><li>把请求分为<u>长度为N</u>的多个队列；一次处理一个队列；新到的请求加到其他队列中。</li><li>特性：<u>N较大时，等价于SCAN；N=1时，等价于FIFO</u></li></ul></li><li>FSCAN</li></ul><div class="note primary modern"><p>如何评价各个磁盘调度</p></div><ul><li>通常情况下，除非有很多请求在队列中，否则，各个算法<strong>没太大区别</strong></li><li>操作系统可以<strong>以执行效率为目的</strong>来按一定的策略放置文件<ul><li><strong>分布式系统</strong>把<u>频繁使用的文件</u>放在磁盘的中间位置</li><li><strong>Ext2文件系统</strong>把<u>inode节点</u>放在磁盘靠近他们所<u>表示的数据块</u>的附近。</li></ul></li></ul><h4 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h4><blockquote><p>作用</p><ul><li>通过<strong>并行</strong>提高性能</li><li>通过<strong>冗余</strong>提高可靠性</li></ul></blockquote><div class="note primary modern"><p>常用层次：RAID0,RAID1.RAID 5,RAID6</p></div><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406040007276.png" alt="image-20240604000729248" style="zoom:80%;" /></p><h3 id="磁盘调度器（Linux）"><a href="#磁盘调度器（Linux）" class="headerlink" title="磁盘调度器（Linux）"></a>磁盘调度器（Linux）</h3><h4 id="电梯调度器-Elevator"><a href="#电梯调度器-Elevator" class="headerlink" title="电梯调度器(Elevator)"></a>电梯调度器(Elevator)</h4><ul><li>使用电梯算法：队列以<strong>块号</strong>进行排序</li></ul><blockquote><p>有一个新的读写请求到达时，会依次考虑4个操作</p><ul><li>如果新请求与队列中的请求在<strong>同一磁盘扇区或相邻的扇区</strong>，则把新请求<strong>合并</strong>进队列</li><li>如果队列中的请求已经<strong>很长时间</strong>了，则新请求将被插入到<strong>队列尾部</strong></li><li>如果<strong>有合适位置</strong>，则新请求将被<strong>按顺序插入队列中</strong></li><li>如果<strong>没有合适的位置</strong>，则新请求将被插入队列的<strong>尾部</strong></li></ul></blockquote><font color="purple">什么叫“请求已经很长时间了”</font><h4 id="Linux-时限IO调度器"><a href="#Linux-时限IO调度器" class="headerlink" title="Linux-时限IO调度器"></a>Linux-时限IO调度器</h4><ul><li>作用：为了防止Linux Elevator出现<strong>长期延迟</strong>问题</li><li>采用3个队列：读请求同时存在于1，2队列中；写请求同时存在于1，3队列中<ul><li><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406040004661.png" alt="image-20240604000422642"></li></ul></li><li>读请求的<strong>默认时限</strong>是0.5秒，写请求5秒。</li></ul><h4 id="Linux-预期IO调度器"><a href="#Linux-预期IO调度器" class="headerlink" title="Linux-预期IO调度器"></a>Linux-预期IO调度器</h4><ul><li>对时限IO调度器的改进</li><li>根据“<strong>局部性</strong>”原理，磁盘请求往往相邻</li><li>当<strong>读请求</strong>被分派时，预期调度器的执行<u>将延迟6毫秒后再决定是否移动磁头到下一个位置</u></li></ul><h2 id="文件系统基本信息"><a href="#文件系统基本信息" class="headerlink" title="文件系统基本信息"></a>文件系统基本信息</h2><h3 id="早期不足"><a href="#早期不足" class="headerlink" title="早期不足"></a>早期不足</h3><details>    <summary>自行展开</summary>    <img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406040011374.png" alt="image-20240604001140344" style="zoom:67%;" /></details><blockquote><p>而后由个人向<strong>系统级</strong>发展，以系统调用的形式向应用程序提供<strong>数据管理服务</strong></p></blockquote><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>方便用户管理自己的数据资源</p><h4 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a><font color="red">基本要求</font></h4><ul><li>文件<strong>按名</strong>存储</li><li>文件有序组织，文件名<strong>分层次</strong>管理<ul><li>如支持树形目录结构</li></ul></li><li>操作简单，<strong>存取效率高</strong>。</li></ul><h4 id="其他要求"><a href="#其他要求" class="headerlink" title="其他要求"></a>其他要求</h4><ul><li>支持<strong>多用户系统</strong>，多用户能够<u>共享同一个磁介质</u></li><li>有一定的<strong>安全性</strong>保证，最好能进行<strong>数据恢复</strong></li><li>存储空间的<strong>利用率</strong>高</li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><strong>文件</strong>：由<u>文件名字</u>标识的一组相关信息的集合。<strong>文件名</strong>是<u>字母或数字</u>组成的字母数字串</li><li><strong>文件系统</strong>:<ul><li>软件观点：操作系统中，为用户和应用程序<u>管理文件</u>的<u>系统软件集合</u></li><li>存储格式观点：文件系统是文件在<u>存储介质上保存和管理相关的约定</u>。在操作系统中，这种约定的实现也被称为文件系统。一种相关约定就对应一种文件系统，所以目前存在多种文件系统：FAT，FAT32，NTFS，EXT2等</li></ul></li><li><strong>一个操作系统</strong>除支持为它设计的文件系统外，<strong>还可能支持其他文件系统</strong></li></ul><h4 id="文件的命名"><a href="#文件的命名" class="headerlink" title="文件的命名"></a>文件的命名</h4><ul><li>文件名是<strong>字母或数字</strong>组成的字母数字串，在一些文件系统中还可能包含其它字符，如<strong>下划线</strong>等</li><li>各种文件系统的文件命名规则略有不同，即文件名的<strong>格式和长度</strong>因系统而异。</li></ul><blockquote><p>长度包括文件路径</p></blockquote><h4 id="文件的类型"><a href="#文件的类型" class="headerlink" title="文件的类型"></a>文件的类型</h4><ul><li><strong>普通文件</strong>：即前面所讨论的<u>存储在外存设备上</u>的数据文件。</li><li><strong>目录文件</strong>：文件在管理普通数据文件时，需要保存其<u>相应的文件和属性</u>，这些属性以目录文件的形式存储在<u>磁盘</u>中。</li><li><strong>块设备</strong>文件：在<u>unix/Linux</u>等操作系统中，对应于<u>磁盘、光盘或磁带</u>等块设备的文件。</li><li><strong>字符设备</strong>文件：在<u>unix/Linux</u>等操作系统中，对应于终端、打印机等<u>字符设备</u>的文件</li></ul><h4 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h4><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406040026701.png" alt="image-20240604002658680" style="zoom:50%;" /></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>用户使用方便</strong>：只要知道文件名，可存取信息，实现了<u>“按名存取”</u></li><li><strong>安全可靠性</strong>：<ul><li>用户<u>通过文件系统才能</u>实现对文件的访问，故可防止对文件信息无意的破坏。</li><li>而文件系统能提供各种<u>安全、保密和保护</u>措施</li></ul></li><li><strong>数据共享</strong><ul><li>移动存储设备</li><li>各种形式的文件链接，不同的用户可以使用<u>同名或异名的同一文件</u></li></ul></li></ul><h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><div class="note primary modern"><p>如果没有设备管理会怎么样</p></div><ul><li>加重应用程序设计者的负担。</li><li>应用程序的<strong><font color="red">移植性</font></strong>比较差</li><li>设备<strong>利用率</strong>低</li></ul><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><div class="note success modern"><p>设备概念</p></div><ul><li>进行<u>实际输入输出操作</u>的<strong>物理设备</strong></li><li><u>控制</u>物理设备的<strong>支持设备和支持部件</strong></li><li>为<u>提高利用率</u>，形成的<strong>逻辑设备</strong>和<strong>虚拟设备</strong>。</li></ul><blockquote><p>用高级编程语言操作的是什么设备</p><p>idk</p></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="外在功能"><a href="#外在功能" class="headerlink" title="外在功能"></a>外在功能</h4><p>输入设备  //  输出设备 //  存储设备  //  供电设备  //  网络设备……</p><h4 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h4><ul><li>块设备</li><li>字符设备</li><li>流设备</li></ul><h4 id="存在形式"><a href="#存在形式" class="headerlink" title="存在形式"></a>存在形式</h4><ul><li>物理设备</li><li>逻辑设备</li></ul><h4 id="资源属性（OS管理）"><a href="#资源属性（OS管理）" class="headerlink" title="资源属性（OS管理）"></a>资源属性（OS管理）</h4><ul><li>共享设备</li><li>独占设备</li><li>虚拟设备</li></ul><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><ul><li>方便、统一的设备<u>使用界面</u>、</li><li>提高<strong>外部设备利用率</strong>，尽量提高<strong>并行程度</strong></li><li>实现<u>程序与设备</u>的<strong>无关</strong>性</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>设备的<strong>配置</strong>和<u>资源分配</u></li><li>设备的<strong>控制和驱动</strong></li><li>系统与设备之间的<strong>缓冲</strong></li><li>协调设备的<strong>调度和分配</strong></li></ul><h4 id="设备管理层次关系"><a href="#设备管理层次关系" class="headerlink" title="设备管理层次关系"></a>设备管理层次关系</h4><ol><li>底层通信（中断处理）<ul><li>实现软件和硬件设备的通信</li></ul></li><li>设备驱动<ul><li>接受来自<u>上层的抽象操作</u>请求，并负责操作的具体实施</li><li>主要组成：与设备打交道的软件、<u>共享支持、缓冲区支持</u>等</li></ul></li><li>对用户层的I/O接口<ul><li>每个I/O调用接口对应具体的<u>设备抽象操作</u></li></ul></li><li>使用设备的用户级程序<ul><li>通过调用所提供的接口来实现对设备的使用或控制</li></ul></li></ol><h2 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h2><blockquote><p><strong>硬件时钟</strong>：由<strong>硬件脉冲</strong>形成，经<strong>计数器和定时器</strong>产生定时中断。</p><p><strong>软件时钟</strong>：由<strong>程序模拟</strong>的时钟，可以产生<font color="red">软中断</font>。</p></blockquote><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul><li><strong>系统时钟</strong>（软时钟）：控制指令执行</li><li><strong>日历时钟</strong>（由软件根据<u>实时时钟</u>设置）</li><li><strong>实时时钟</strong> (Real-time clock): 提醒处理器有其他事情要做（也就是产生<u>硬件中断</u>）</li></ul><div class="note success modern"><p>系统时钟的维护</p></div><p>在计算机<strong>没有启动</strong>时。<u>主板</u>上包含了一个类似<u><strong>石英钟</strong>的物理时钟</u>在记录时间的流逝和变化</p><p>系统<strong>启动</strong>时，OS从<u>物理时钟</u>读取当前时间，保存在<u>全局变量</u>里。时间度量单位为Tick。</p><p>每过一个Tick（即一个计时单位，由操作系统定义），<u>时钟芯片都会向CPU发送一个时钟中断</u>。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><ul><li>紧急任务（1个tick，例如1ms）：<ul><li><u>运行进程</u>的优先级调整</li><li>终端<u>延时</u>处理</li></ul></li><li>非紧急任务（例如，1秒）：<ul><li>非运行态进程的优先级调整</li></ul></li></ul><h2 id="OS控制IO操作"><a href="#OS控制IO操作" class="headerlink" title="OS控制IO操作"></a>OS控制IO操作</h2><h3 id="硬件组成"><a href="#硬件组成" class="headerlink" title="硬件组成"></a>硬件组成</h3><ul><li><strong>机械部件</strong>（<strong>实施</strong>部件）：具体实现设备的操作</li><li><strong>电子部件</strong>（<strong>接口</strong>部件）：又叫设备控制器<ul><li>直接外接用于<u>控制和数据通信</u>的<u>电缆线</u></li><li>操作系统与<u>控制器</u>直接打交道，发送操作命令，或收发数据</li><li>控制器接收OS发来的操作指令，控制机械部件完成相应操作</li></ul></li></ul><h3 id="资源分配"><a href="#资源分配" class="headerlink" title="资源分配"></a>资源分配</h3><h4 id="I-O地址"><a href="#I-O地址" class="headerlink" title="I/O地址"></a>I/O地址</h4><ul><li><u>设备内部</u>的I/O编址：局限于单个设备</li><li><u>整个系统</u>I/O编址：需要把单个设备的I/O编址<strong>映射</strong>到系统全局编址<ul><li>与内存统一编址：同一般的内存访问操作</li><li>与内存分开编址：需要使用<u>专门的I/O指令</u>访问设备控制器的寄存器</li></ul></li></ul><blockquote><p>在设备接入之后，需要<strong>分配合适的I/O地址</strong>。设备内部的I/O地址要<strong>映射到所分配的I/O地址上</strong></p></blockquote><h4 id="I-O中断请求"><a href="#I-O中断请求" class="headerlink" title="I/O中断请求"></a>I/O中断请求</h4><ul><li>中断控制器支持的<strong>中断数量有限</strong>，每个进行了编号</li><li>设备接入系统后，需要<strong>分配中断号</strong>。一般情况下，多个设备<strong>不能共享</strong>同一中断号</li></ul><blockquote><p>没有合适的中断编号设备就<strong>不能正常工作</strong>。</p></blockquote><h4 id="DMA数据传输通道"><a href="#DMA数据传输通道" class="headerlink" title="DMA数据传输通道"></a>DMA数据传输通道</h4><div class="note primary modern"><p>关于IO通道</p></div><ul><li>I/O通道是一种硬件设施，带有<u>专用处理器</u>的，是有很强I/O处理功能的智能部件</li><li>可以<font color="blue">独立地完成系统处理器交付的I/O操作任务</font>，通道具有自己<strong>专门的指令集</strong>，即<strong>通道指令</strong></li><li>通道执行来自处理器的通道程序，完成后只需<u>向系统处理器发出中断</u>，请求结束</li></ul><div class="note primary modern"><p>IO通道分类</p></div><ul><li><strong>字节多路通道</strong><ul><li>用于连接<font color="blue">大量</font><font color="red">低、中速</font>的I/O设备，每次传输一个字节</li><li>以<strong>字节为单位</strong>交叉地工作，<font color="red">当为一台设备传送一个字节后，立即转去为另一台设备传送一个字节</font></li></ul></li><li><strong>选择通道</strong><ul><li>用于支持<font color="red">高速设备</font>（如磁盘），每次只与<font color="blue">一个设备</font>进行数据传输</li><li>数据传输是<strong>以块为单位</strong>，每次可以传输一批数据</li><li><font color="red">每当一个输入输出操作请求完成后，再选择与通道相连接的另一设备</font></li></ul></li><li><strong>成组多路通道</strong><ul><li>以<strong>分时方式</strong>同时执行几道通道程序，分别实现与<font color="blue">几个高速设备</font>的数据传输</li><li>实质是<font color="red">对通道程序采用多道程序设计技术的硬件实现</font> 。 </li></ul></li></ul><div class="note success modern"><p>DMA传输通道</p></div><ul><li><strong>内存和I/O设备之间</strong>的自动化数据通路，在主存和I/O设备之间成块传送数据过程中，<font color="red">不需要CPU干预</font>，CPU资源的利用率再次得到提高</li><li>DMA不仅设有中断机构，而且，还增加了DMA<strong>传输控制机构</strong>（类似于CPU)</li></ul><h4 id="I-O缓冲区"><a href="#I-O缓冲区" class="headerlink" title="I/O缓冲区"></a>I/O缓冲区</h4><ul><li><strong>需求</strong><ul><li>提高CPU和外设的<u>并行度</u></li><li>缓解<u>外设速度慢</u>的瓶颈</li></ul></li><li>分类<ul><li>硬件缓冲：有些设备中会包含专门的硬件寄存器等用于缓冲。</li><li>软件缓冲：直接在主存中<ul><li>单缓冲：一个缓冲，外设和CPU<u>互斥进行操作</u></li><li>双缓冲：设置两个缓冲区，交替使用</li><li>循环缓冲：类似于<u>循环队列</u>，依次使用</li><li><font color="red">缓冲池</font>：系统维护一组大小相同的缓冲区，进程和设备<strong>按需要申请</strong>，使用完后重新归入缓冲池中</li></ul></li></ul></li></ul><h3 id="资源控制"><a href="#资源控制" class="headerlink" title="资源控制"></a>资源控制</h3><p>使用<strong>设备控制表（DCT）</strong>控制设备。</p><h4 id="设备控制表（DCT）"><a href="#设备控制表（DCT）" class="headerlink" title="设备控制表（DCT）"></a>设备控制表（DCT）</h4><ul><li><p>作用：将抽象的<strong>I/O操作</strong>映射到实际的设备</p></li><li><p>记录内容：</p><ul><li>抽象设备描述</li><li>实际<u>设备地址</u></li><li>驱动程序参数等</li></ul></li><li><details>]    <summary>示例</summary>    <img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406050040213.png" alt="image-20240605004011179" style="zoom:80%;" /></details></li></ul><h4 id="设备开关表"><a href="#设备开关表" class="headerlink" title="设备开关表"></a>设备开关表</h4><ul><li>内容<ul><li>·设备号（对应于DCT中的设备号）</li><li><font color="red">打开设备的程序入口地址</font></li><li><font color="red">关闭设备的程序入口地址</font></li></ul></li></ul><h2 id="Unix设备的管理分配"><a href="#Unix设备的管理分配" class="headerlink" title="Unix设备的管理分配"></a>Unix设备的管理分配</h2><h3 id="管理层次"><a href="#管理层次" class="headerlink" title="管理层次"></a>管理层次</h3><p>设备文件-&gt;设备开关表-&gt;驱动程序-&gt;I/O指令（控制寄存器）-&gt;硬件</p><h3 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h3><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><ul><li>为进程或作业分配所需的设备</li><li><font color="red">充分发挥设备的使用效率，尽可能避免**死锁**</font></li></ul><h4 id="分配方式"><a href="#分配方式" class="headerlink" title="分配方式"></a>分配方式</h4><ul><li>静态分配：<ul><li>作业开始运行时，一次性分配给所有可能使用到的设备</li><li>设备利用率低</li><li>简单，<u>不会出现死锁</u></li></ul></li><li>动态分配<ul><li>进程使用设备时再进行相应分配</li><li>设备利用高，<u>可能会出现死锁</u></li></ul></li></ul><h4 id="设备请求管理"><a href="#设备请求管理" class="headerlink" title="设备请求管理"></a>设备请求管理</h4><ul><li>要使用设备时<font color="red">必须</font>提供进行<u>I/O操作的有关信息</u>，指出执行I/O的逻辑<u>设备名</u>（如设备号）、<u>操作类型</u>、传送数据的<u>数目</u>、<u>信息源或目的地址</u>等。</li><li>存放进行I/O操作的信息的结构称为<font color="blue"> <strong>I/O请求块</strong> </font><ul><li>在UNIX系统中，系统的I/O请求块的内容是<font color="red">包含在缓冲区控制块buf</font>中</li></ul></li></ul><blockquote><p>在请求I/O时，首先<strong>请求分配缓冲区</strong>，然后把与操作有关的信息写到buf中，并把这个<strong>buf挂到请求设备的I/O请求队列</strong>中去</p></blockquote><h4 id="分配原则"><a href="#分配原则" class="headerlink" title="分配原则"></a>分配原则</h4><ul><li>独占设备：同时只能分配给<strong>一个请求进程</strong>。</li><li>共享设备：同时可以将一个设备分配给<strong>多个请求进程</strong>。</li><li>虚拟设备：用一个逻辑设备来<u>同时模拟</u><strong>多个独占</strong>设备，达到设备共享的目的，<u>提高设备利用率</u>。</li></ul><h1 id="遗留作业"><a href="#遗留作业" class="headerlink" title="遗留作业"></a>遗留作业</h1><ol><li><p>磁盘调度</p><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406032358632.png" alt="image-20240603235836608" style="zoom:80%;" /></p></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
          <category> class </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> 2023-2024Spring </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/05/26/hello-world/"/>
      <url>/2024/05/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
