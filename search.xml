<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>monad概览</title>
      <link href="/2024/06/03/monad%E6%A6%82%E8%A7%88/"/>
      <url>/2024/06/03/monad%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li><code>m</code>类型构造子</li><li><code>return :: a -&gt; M a</code>：（也叫做<code>unit</code>），接受一个类型<code>a</code>的值，把它们包装成使用这个类型构造子建造的类型<code>m a</code>的“单子值”</li><li><code>bind :: (M a) -&gt; (a -&gt; M b) -&gt; (M b)</code> ：也可写作 <code>&gt;&gt;=</code>，接受一个在类型<code>a</code>上的函数<code>f</code>，并应用<code>f</code>于去包装的值<code>a</code>，转变单体值<code>m a</code>。</li></ul><p>通过以上元素，复合出一个函数调用的序列，在一个表达式中通过一些<strong>bind算子</strong>把它们链接起来。</p><p>每个函数调用<u>转变</u>它的输入普通类型值，而bind算子<u>处理返回的单子值</u>，它被填入到序列中下一个步骤。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><div class="note primary modern"><p>案例：maybe</p></div><ul><li>需要显示定义函数的返回状态：<code>Just ⌑result⌑</code>, or <code>Nothing</code></li></ul><p>案例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(x: Decimal, y: Decimal) <span class="punctuation">-&gt;</span> Maybe&lt;Decimal&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> y == <span class="number">0</span> &#123; <span class="keyword">return</span> Nothing &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="title function_ invoke__">Just</span>(x / y) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// divide(1.0, 4.0) -&gt; returns Just(0.25)</span></span><br><span class="line"><span class="comment">// divide(3.0, 0.0) -&gt; returns Nothing</span></span><br></pre></td></tr></table></figure><ul><li>检查<code>Maybe</code>算子返回的值(上)或使用类型匹配（下）</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">m_x</span> = <span class="title function_ invoke__">divide</span>(<span class="number">3.14</span>, <span class="number">0.0</span>); <span class="comment">// see divide function above</span></span><br><span class="line"><span class="comment">// The if statement extracts x from m_x if m_x is the Just variant of Maybe</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Just</span>(x) = m_x &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;answer: &quot;</span>, x)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;division failed, divide by zero error...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">divide</span>(<span class="number">3.0</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="keyword">match</span> result &#123;</span><br><span class="line">    <span class="title function_ invoke__">Just</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Answer: &quot;</span>, x),</span><br><span class="line">    Nothing =&gt; <span class="built_in">println!</span>(<span class="string">&quot;division failed; we&#x27;ll get &#x27;em next time.&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多输入monad，单输出monad</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">chainable_division</span>(maybe_x: Maybe&lt;Decimal&gt;, maybe_y: Maybe&lt;Decimal&gt;) <span class="punctuation">-&gt;</span> Maybe&lt;Decimal&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> (maybe_x, maybe_y) &#123;</span><br><span class="line">        (<span class="title function_ invoke__">Just</span>(x), <span class="title function_ invoke__">Just</span>(y)) =&gt; &#123; <span class="comment">// If both inputs are Just, check for division by zero and divide accordingly</span></span><br><span class="line">            <span class="keyword">if</span> y == <span class="number">0</span> &#123; <span class="keyword">return</span> Nothing &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="title function_ invoke__">Just</span>(x / y) &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> Nothing <span class="comment">// Otherwise return Nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">chainable_division</span>(<span class="title function_ invoke__">chainable_division</span>(<span class="title function_ invoke__">Just</span>(<span class="number">2.0</span>), <span class="title function_ invoke__">Just</span>(<span class="number">0.0</span>)), <span class="title function_ invoke__">Just</span>(<span class="number">1.0</span>)); <span class="comment">// inside chainable_division fails, outside chainable_division returns Nothing</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>&gt;&gt;=</code>来传递多次匿名函数；多参数处理</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">halve</span> :: <span class="type">Int</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">halve</span> x</span><br><span class="line">  | even x = <span class="type">Just</span> (x `div` <span class="number">2</span>)</span><br><span class="line">  | odd x  = <span class="type">Nothing</span></span><br><span class="line"> <span class="comment">-- This code halves x twice. it evaluates to Nothing if x is not a multiple of 4</span></span><br><span class="line"><span class="title">halve</span> x &gt;&gt;= halve</span><br></pre></td></tr></table></figure><blockquote><p>x >>= y即把x传递给函数y获得返回值</p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">chainable_division</span>(mx,my) =   mx &gt;&gt;=  ( λx -&gt;   my &gt;&gt;= (λy -&gt; <span class="type">Just</span> (x / y))   )</span><br></pre></td></tr></table></figure><blockquote><p>在此处的$\lambda$表示匿名函数</p></blockquote><p>在上面的案例中，有以下几种类型：</p><ul><li><em>Monadic Type</em>：<code>Maybe</code></li><li><em>Unit operation</em>（类型转换）：<code>Just(x)</code></li><li><em>Bind operation</em>（组合子）： <code>&gt;&gt;=</code> or <code>.flatMap()</code></li></ul><h1 id="标准定义"><a href="#标准定义" class="headerlink" title="标准定义"></a>标准定义</h1><h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><ul><li><p><strong>A <a href="https://en.wikipedia.org/wiki/Type_constructor">type constructor</a></strong> <em>M</em> that builds up a <strong>monadic type</strong> <code>M T</code></p></li><li><p><strong>type converter</strong>常被叫做 <strong>unit</strong> or <strong>return</strong>，用于将一个对象<code>x</code>嵌入到单子中，<code>unit(x) :: T -&gt; M T</code></p></li><li><p><strong>combinator</strong> 典型的叫做<strong>bind</strong>，并表示为中缀算子<code>&gt;&gt;=</code>，去<u>包装</u>一个单体变量，接着把它插入到一个单体函数/表达式之中，结果为一个新的单体值：</p></li><li><code>(&gt;&gt;=) : (M T, T → M U) → M U</code>so if <code>mx : M T</code> and <code>f : T → M U</code>, then <code>(mx &gt;&gt;= f) : M U</code></li></ul><h2 id="遵循定律"><a href="#遵循定律" class="headerlink" title="遵循定律"></a>遵循定律</h2><ul><li>unit是bind的左单比特 <code>unit(x) &gt;&gt;= f</code> <strong>↔</strong> <code>f(x)</code></li><li>unit是bind的右单比特 <code>ma &gt;&gt;= unit</code> <strong>↔</strong> <code>ma</code></li></ul><blockquote><p>此处左单比特、右单比特即单位元，identity</p></blockquote><ul><li>bind符合结合律 <code>ma &gt;&gt;= λx → (f(x) &gt;&gt;= g)</code> <strong>↔</strong> <code>(ma &gt;&gt;= f) &gt;&gt;= g</code></li></ul><blockquote><p>单子构成在函子（functor）范畴上的<a href="https://zh.wikipedia.org/wiki/%E5%B9%BA%E5%8D%8A%E7%BE%A4">幺半群</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
          <category> functional programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> function programming </tag>
            
            <tag> monad </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIS2336</title>
      <link href="/2024/06/02/NIS2336/"/>
      <url>/2024/06/02/NIS2336/</url>
      
        <content type="html"><![CDATA[<h1 id="概论">概论</h1><h2 id="概念">概念</h2><ul class="task-list"><li><p><label><inputtype="checkbox" />翻译程序：源语言、源程序、目标语言、目标程序</label></p></li><li><p><label><input type="checkbox" />编译程序</label></p></li><li><p><label><inputtype="checkbox" />编译的两大（编译和运行)/三大阶段(编译、汇编和运行）及区别（编译阶段生成的目标程序）</label></p></li><li><p><label><inputtype="checkbox" />解释程序和编译程序的主要区别</label></p></li><li><p><label><inputtype="checkbox" />编译的六个阶段、前端和后端</label></p></li><li><p><label><inputtype="checkbox" />词法分析：源程序、字符串、扫描分解、单词/单词符号/符号</label></p></li><li><p><label><inputtype="checkbox" />语法分析：单词符号串、语法规则、识别语法单位、检查</label></p></li><li><p><label><inputtype="checkbox" />语义分析、中间代码生成：语法单位、<strong>静态语义省查</strong>、分析含义、<u>另一种 </u> 语言描述（什么语言？）</label></p></li><li><p><label><inputtype="checkbox" />代码优化：对（）进行（）改造或变换，高效，主要包括（局部优化）和（循环优化）</label></p><ul class="task-list"><li><label><inputtype="checkbox" />目标代码生成：将中间代码变换成（绝对指令代码）或（可重定位指令代码）或（汇编指令代码）</label></li></ul></li><li><p><label><input type="checkbox" />在 <strong>每个</strong>过程中，涉及 <u> 表格管理和错误处理</u>：表格的构造、查找、修改、存取</label></p></li></ul><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/study/NIS2334/image-20240530102430879.png" alt="编译流程" style="zoom: 50%;" /></p><h2 id="判断">判断</h2><ul class="task-list"><li><label><inputtype="checkbox" />上面的图中的流程是逻辑关系吗？是执行时间上的先后关系吗？可按照不同的执行流程来组织吗？</label><ul class="task-list"><li><label><inputtype="checkbox" />相关：一遍扫描?多遍扫描？开始和结束？优缺点？</label></li></ul></li><li><label><input type="checkbox" />编译程序：复杂系统程序</label></li></ul><h1 id="文法和语言">文法和语言</h1><h2 id="概念-1">概念</h2><h3 id="字母表和符号串">字母表和符号串</h3><ul><li><p><label><inputtype="checkbox" />字母表：含义、个数、类型</label></p></li><li><p><label><input type="checkbox" />符号/字符</label></p></li><li><p><label><input type="checkbox" />符号串：有穷、特定、空 <spanclass="math inline">\(\epsilon\)</span>，<spanclass="math inline">\(|\epsilon|=0\)</span></label></p></li><li><p><label><inputtype="checkbox" />运算：符号串（连接、幂运算）集合（乘积-所有符号串、闭包、正闭包）</label></p></li><li><p><span class="math inline">\(\epsilon\)</span> 是空符号串，<spanclass="math inline">\(\{\epsilon\}\)</span> 是 <spanclass="math inline">\(\epsilon\)</span> 组成的集合，<spanstyle="color:#CC0000;"> 不是空集合 </span>，<spanclass="math inline">\(\Phi=\{\}\)</span> 是空集合</p></li></ul><h3 id="文法形式化">文法形式化</h3><ul><li><p><label><inputtype="checkbox" />形式语言（字母表、规则、符号串）、描述方法（枚举、文法）</label></p></li><li><p><label><inputtype="checkbox" />规则/产生式：终结符与非终结符</label></p></li><li><p><label><input type="checkbox" />文法：四元组（<spanclass="math inline">\(V_N,V_T,P,S\)</span>）、字汇表（<spanclass="math inline">\(V\)</span>）、关键、候选式与识别符号</label></p></li><li><p>序列的集合成为形式语言</p></li><li><p>形式语言 <span style="color:#CC0000;"> 不考虑语义</span></p></li><li><p>设计的文法不能超出所定义语言的范围</p></li></ul><h3 id="推导与规约">推导与规约</h3><ul><li><p><label><input type="checkbox" />推导：</label></p><ul class="task-list"><li><label><input type="checkbox" />直接推导（<spanclass="math inline">\(xAy\Rightarrow xay\)</span> 且 <spanclass="math inline">\(A\rightarrow a\)</span>）, 仅使用 <spanstyle="color:#CC0000;"> 一次 </span> 规则</label></li><li><label><input type="checkbox" />推导：<spanclass="math inline">\(a_0\xRightarrow{+}a_n\)</span>，长度为 n(<spanclass="math inline">\(n\gt 0\)</span>)的推导</label></li><li><label><input type="checkbox" />广义推导：<spanclass="math inline">\(a_0\xRightarrow{*}a_n\)</span> 长度为 n(<spanclass="math inline">\(n\ge 0\)</span>)</label></li></ul></li><li><p><label><input type="checkbox" />句型与句子、语言（<spanstyle="color:#CC0000;"> 句子 </span> 的集合）</label></p></li><li><p><label><inputtype="checkbox" />最左推导/最右推导（规范推导）、规范句型</label></p></li><li><p><label><inputtype="checkbox" />最左规约（规范规约）/最右规约</label></p></li><li><p><label><inputtype="checkbox" />规则/文法的左递归/右递归/递归（哪一边不变？）</label></p></li><li><p>文法给定，则语言确定，且 <spanclass="math inline">\(L(G)\subseteq V_T^*\)</span></p></li><li><p>文法的递归需要至少一步推导</p></li><li><p>递归使得我们能用有限的规则定义无穷集合的语言</p></li></ul><h3 id="语法树短语文法二义性">语法树、短语、文法二义性</h3><ul><li><p><label><inputtype="checkbox" />语法树、子树、简单子树</label></p></li><li><p><label><inputtype="checkbox" />短语（终结符）、直接短语、句柄（最左直接短语）</label></p></li><li><p><label><inputtype="checkbox" />文法二义性：两个语法树/两个不同的最左或最右推导</label></p></li><li><p><label><inputtype="checkbox" />语言二义性/先天二义性（举例：<spanclass="math inline">\(L=\{a^i b^j c^k|i=j或j=k且i,j,k\ge1\}\)</span>）</label></p></li><li><p>语法树和短语等的关系</p><ul><li>短语：子树的末端结点符号串是相对于子树根的短语</li><li>直接短语：简单子树的末端结点符号串是相对于简单子树根的短语</li><li>句柄：最左简单子树的末端结点形成的符号串</li></ul></li><li><p>短语、直接短语和句柄是<spanstyle="color:#CC0000;">针对某一句型</span>的</p></li></ul><h3 id="文法和语言的分类">文法和语言的分类</h3><ul class="task-list"><li><label><inputtype="checkbox" />0型文法/无限制文法/无限制语言</label></li><li><label><input type="checkbox" />1型文法/上下文有关文法</label></li><li><label><input type="checkbox" />2型文法/上下文无关文法</label></li><li><label><inputtype="checkbox" />3型文法/正规文法/左右线型文法/正规语言（展开的是哪里的终结符?留下的是哪里的非终结符？）</label></li><li><label><input type="checkbox" />正规文法<spanclass="math inline">\(\subseteq\)</span>上下文无关<spanclass="math inline">\(\subseteq\)</span>上下文有关<spanclass="math inline">\(\subseteq\)</span>无限制</label></li><li><label><inputtype="checkbox" />文法限制：有害规则、多余规则</label></li></ul><h2 id="判断-1">判断</h2><ul class="task-list"><li><label><input type="checkbox" />形式语言考虑语义。（x）</label></li><li><label><inputtype="checkbox" />每个非终结符表示一定符号串的集合。（√）</label></li><li><label><input type="checkbox" />推导的依据是 <spanstyle="text-decoration:underline;"> 规则 </span>(√)</label></li><li><label><inputtype="checkbox" />当一个语言是无穷集合时，定义该语言的文法不一定是递归的。（×）</label></li></ul><h2 id="题型">题型</h2><h3 id="文法的设计">文法的设计</h3><ul><li><strong>根据字母表设计文法</strong></li></ul><blockquote><p>相同的幂必须合并在一起</p></blockquote><p>例题：设字母表 <spanclass="math inline">\(\Sigma=\{a,b\}\)</span>，尝试设计一个文法描述语言<span class="math inline">\(L=\{a^n b^n|n\ge 0\}\)</span></p><p>解：</p><p><spanclass="math inline">\(V_T=\{a,b\}\\V_N=\{L\}\\P=\{L\rightarrow\epsilon|aLb\}\\S=L\)</span></p><h3 id="证明是句型句子">证明是句型、句子</h3><blockquote><p>证明有相应的推导即可</p></blockquote><p>例题：设有文法 <span class="math inline">\(G[E]:E\rightarrowE+E|E*E|(E)|i\)</span>，尝试证明符号串 <spanclass="math inline">\((i*i+i)\)</span> 是 <spanclass="math inline">\(G[E]\)</span> 的一个句子</p><p>解：<span class="math inline">\(E \Rightarrow(E)\Rightarrow(E+E)\Rightarrow(E*E+E)\Rightarrow(i*E+E)\Rightarrow(i*i+E)\Rightarrow(i*i+i)\)</span></p><h3 id="从已知文法确定语言">从已知文法确定语言</h3><blockquote><p>中心思想: 从开始符号出发, 反复使用规则, 对非终结符施行替换和展开</p></blockquote><p>例题: <span class="math inline">\(G[S]:S\rightarrow 01|0S1\)</span>解答：<span class="math inline">\(L(G[S])={0^n1^n|n\ge 1}\)</span></p><h3 id="推导与规约-1">推导与规约</h3><ul><li>最左推导与最右推导示例</li></ul><p>例题：设文法 <span class="math inline">\(G[S]:S\rightarrow AB;A\rightarrow A0|1B;B\rightarrow 0|S1\)</span> 给出句子 101001的最左和最有推导</p><p>最右推导： <span class="math display">\[\begin{aligned}S &amp;\Rightarrow AB \Rightarrow AS1 \Rightarrow AAB1 \RightarrowAA01\\&amp;\Rightarrow A1B01 \Rightarrow A1001 \Rightarrow 1B1001\\&amp;\Rightarrow101001\end{aligned}\]</span> 最左推导： <span class="math display">\[\begin{aligned}S &amp;\Rightarrow AB \Rightarrow 1BB \Rightarrow 10B \Rightarrow 10S1\\&amp;\Rightarrow 10AB1 \Rightarrow 101BB1 \Rightarrow 1010B1\\&amp;\Rightarrow101001\end{aligned}\]</span></p><h3 id="求短语直接短语句柄">求短语、直接短语、句柄</h3><blockquote><p>通过推导关系建立语法树，从而求出上述内容</p></blockquote><p>例题：设有文法<spanclass="math inline">\(G[S]=(\{S,A,B\},\{a,b\},P,S)\)</span>，求出句型<spanclass="math inline">\(baSb\)</span>的短语、直接短语和句柄，其中<spanclass="math inline">\(P\)</span>为： <span class="math display">\[S \rightarrow AB\\A \rightarrow Aa|bB\\B \rightarrow a|Sb\]</span> 列出子树：</p><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406172216255.png" alt="image-20240617221603230" style="zoom:50%;" /></p><p>则短语为：<spanclass="math inline">\(a,ba,Sb,baSb\)</span>，直接短语为<spanclass="math inline">\(a\)</span>，句柄为<spanclass="math inline">\(a\)</span></p><p>注意：<spanstyle="color:#CC0000;">直接短语直接找只有一个叶子结点的子树，句柄找最左边的直接短语</span></p><h3 id="消除文法二义性">消除文法二义性</h3><blockquote><p>1.定义优先级，左右结合性</p><p>2.构造无二异性文法</p></blockquote><p>例：构造无二义性文法，使得<spanclass="math inline">\(*\)</span>优先级高于<spanclass="math inline">\(+\)</span></p><p>定义文法如下：（层层递推） <span class="math display">\[EXPR1 \rightarrow EXPR2*EXPR2|EXPR2\\EXPR2 \rightarrow EXPR3+EXPR3|EXPR3\\EXPR3 \rightarrow (EXPE1)\]</span> <strong>说明文法二义性</strong>：画出两颗不同的语法树即可</p><h1 id="词法分析">词法分析</h1><h2 id="概念-2">概念</h2><h3 id="单词符号与定义方式">单词符号与定义方式</h3><p><strong>单词符号</strong></p><ul class="task-list"><li><label><input type="checkbox" />单词符号（独立、<spanstyle="color:#CC0000;">最小语法</span>单位）：关键字、标识符、常数、运算符、界符</label></li><li><label><inputtype="checkbox" />单词符号二元式（种类、值）</label></li></ul><p><strong>正规式与正规集</strong></p><ul><li><p><label><input type="checkbox" />简单正规式：<spanclass="math inline">\(\Phi\)</span>（空集）、<spanclass="math inline">\(\epsilon\)</span>（空符号串 $ {}<spanclass="math inline">\(）、\)</span>a_i<spanclass="math inline">\(（\)</span>{a_i}$）</label></p></li><li><p><label><input type="checkbox" />规则：<spanclass="math inline">\(e_1|e_2\)</span>、<span class="math inline">\(e_1e_2\)</span>、<spanclass="math inline">\(e_1^*\)</span>（左结合，优先级：闭包&gt;连接&gt;或）</label></p></li><li><p><label><inputtype="checkbox" />正规式的性质：交换律、结合律、<strong>分配律</strong>、单位元、闭包运算</label></p></li><li><p>不能用正规文法表示的不能算作正规集</p></li><li><p>注意正规式与正规文法的区别和联系</p></li></ul><h3 id="有穷自动机">有穷自动机</h3><ul><li><p><label><input type="checkbox" />五元组（Q，<spanclass="math inline">\(\Sigma\)</span>，f，S，Z）(f和S在NFA和DFA中的不同含义）</label></p></li><li><p><label><inputtype="checkbox" />状态转移矩阵与状态转换图</label></p><p><imgsrc="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406172348044.png"alt="image-20240617234851007" /></p><p><imgsrc="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406172352359.png"alt="image-20240617235205325" /></p></li><li><p><label><input type="checkbox" />被识别/被接受、DFAM识别的语言</label></p></li><li><p><label><inputtype="checkbox" />利用自动机构造词法分析程序的流程</label></p></li><li><p>对于每个NFA M，存在DMA M’，使得L(M)=L(M’)</p></li></ul><h2 id="题型-1">题型</h2><h3 id="由正规式求正规集">由正规式求正规集</h3><blockquote><p>可以用枚举法或者形式化语言表示</p><p>注意化为形式化语言时，<strong>或、闭包、连接运算怎么转换</strong></p></blockquote><p><strong>枚举法</strong></p><p><spanclass="math inline">\(ba^*:L(ba^*)=L(b)L(a^*)=\{b,ba,baa,\dots\}\)</span></p><p><strong>形式化语言</strong></p><p><span class="math inline">\((a|b)^*(aa|bb)(a|b)^*:\)</span></p><p><spanclass="math inline">\(L((a|b)^*(aa|bb)(a|b)^*)=L((a|b)^*)L(aa|bb)L((a|b)^*)=\{a,b\}^*\{aa,bb\}\{a,b\}^*\)</span></p><h3 id="由正规文法求正规集">由正规文法求正规集</h3><blockquote><ol type="1"><li>列出联立方程式：<span class="math inline">\(x=\alpha x|\beta\Rightarrow x=\alpha^*\beta\)</span>以及<spanclass="math inline">\(x=x\alpha|\beta \Rightarrowx=\beta\alpha^*\)</span></li><li>通过分配交换结合律解方程</li></ol></blockquote><p>例题：求中的正规式</p><p><imgsrc="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406172330519.png"alt="image-20240617233051488" /></p><ul><li>首先，列出方程（将或运算变为加号）</li><li><imgsrc="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406172332226.png"alt="image-20240617233224199" /></li><li>然后依次带入求解</li><li><imgsrc="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406172332379.png"alt="image-20240617233250353" /></li><li><imgsrc="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406172332435.png"alt="image-20240617233259410" /></li><li>最后化为正规式</li><li><imgsrc="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406172333037.png"alt="image-20240617233314011" /></li></ul><h3 id="由正规式求正规文法">由正规式求正规文法</h3><blockquote><p>到G的转换如下</p><ol type="1"><li><span class="math inline">\(V_T=\Sigma\)</span></li><li><span class="math inline">\(S=Z\rightarrow R\)</span></li><li><span class="math inline">\(A\rightarrow ab: A\rightarrow aB,B\rightarrow b\)</span></li><li><span class="math inline">\(A\rightarrow a^*b :A\rightarrowaA|b\)</span></li></ol></blockquote><p>例子：将<spanclass="math inline">\(R=(a|b)(aa)^*(a|b)\)</span>转化为正规文法</p><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406172343414.png" alt="image-20240617234357373" style="zoom:80%;" /></p><p>每一个推导式中只能出现<spanstyle="color:#CC0000;">一个非终结符</span></p><h3 id="由正规式求nfa">由正规式求NFA</h3><p><strong>步骤</strong></p><ol type="1"><li><p>引入初始节点和终止节点</p><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406172355589.png" alt="image-20240617235534559" style="zoom:80%;" /></p></li><li><p>对于基本符号构造NFA</p><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406172356804.png" alt="image-20240617235610774" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406172356488.png" alt="image-20240617235623462" style="zoom:80%;" /></p></li><li><p>对于复合正规式构造节点</p><p><imgsrc="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406172357970.png"alt="image-20240617235708937" /></p></li></ol><h3 id="由nfa求dfa">由NFA求DFA</h3><p><strong>子集法</strong></p><p>画出<strong>状态矩阵</strong>以及确定化DFA图</p><ol type="1"><li>求状态集合，得到某字符+空串能到达的状态。若不同，则为新状态</li></ol><p><strong>DFA的化简</strong></p><ul><li>没有多余状态和等价状态</li></ul><ol type="1"><li>划分终态集和非终态集。</li><li>路径化简，按路径化简划分集合，若为已有集合的子集，则不用划分，若不为已有集合的子集，则需要划分</li></ol><p>参考：<ahref="https://www.bilibili.com/video/BV1rY411J7cR/?spm_id_from=333.337.search-card.all.click&amp;vd_source=5770856d2f35c8b47bf20bc120936faf">DFA化简一看就会 自己和解_哔哩哔哩_bilibili</a></p><ul><li>答题的时候用官方语言描述：</li></ul><p><imgsrc="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406180120644.png"alt="image-20240618012004595" /></p><h3 id="有穷自动机转为正规式">有穷自动机转为正规式</h3><ol type="1"><li><p>增加X节点和Y节点，X连结到所有初态，Y连结到所有终态</p></li><li><p>逐步消去M’中的其他结点，消除方式如下：</p><p><imgsrc="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406180128651.png"alt="image-20240618012811609" /></p></li></ol><h3 id="正规文法与有穷自动机的转换"><spanstyle="color:#CC0000;">正规文法与有穷自动机的转换</span></h3><p><strong>右线性正规文法转有穷自动机</strong></p><ol type="1"><li>获取Q:<span class="math inline">\(V_N+D\)</span>，Z:<spanclass="math inline">\(D\)</span>，<spanclass="math inline">\(\Sigma:V_T\)</span>，<spanclass="math inline">\(q_0:S\)</span></li><li><span class="math inline">\(A \rightarrow aB \Rightarrowf(A,a)=B\)</span></li><li><span class="math inline">\(A \rightarrow a \Rightarrowf(A,a)=D\)</span></li><li><span class="math inline">\(A \rightarrow \epsilon \Rightarrowf(A,\epsilon)=D\)</span></li></ol><p><strong>左线性正规文法转有穷自动机</strong></p><ol type="1"><li>获取Q:<span class="math inline">\(V_N+q_0\)</span>，Z:<spanclass="math inline">\(S\)</span>，<spanclass="math inline">\(\Sigma:V_T\)</span>，<spanclass="math inline">\(q_0:q_0\)</span></li><li><span class="math inline">\(A \rightarrow Ba \Rightarrowf(B,a)=A\)</span></li><li><span class="math inline">\(A \rightarrow a \Rightarrowf(q_0,a)=A\)</span></li></ol><p><strong>有穷自动机到正规文法</strong></p><ol type="1"><li><p><span class="math inline">\(V_N =Q,V_T=\Sigma,S=q_0\)</span></p></li><li><p><span class="math inline">\(f(A,a)=B,B\notin Z \Rightarrow A\rightarrow aB\)</span></p></li><li><p><span class="math inline">\(f(A,a)=B,B\in Z \Rightarrow A\rightarrow aB|a,B\rightarrow \epsilon\)</span></p></li><li><p><span class="math inline">\(S\)</span>为终态 <spanclass="math inline">\(\Rightarrow S \rightarrow\epsilon\)</span></p></li></ol><p>在化简时要注意有没有多余状态：只进不出</p><h1 id="语法分析">语法分析</h1><h2 id="概念-3">概念</h2><ul><li>自上而下、自下而上分析方法、非确定性自上而下，确定的自上而下（无左递归、无回溯）</li><li>回溯的原因（右部左端第一个符号相同、某一右部推出空串）</li><li>LL1文法（无回溯）</li><li>递归下降分析法（非终结符、函数、LL1）</li><li>预测分析法：构输入缓冲区、分析栈、预测分析表、预测分析器</li><li>自下而上的原理（移进、规约）（可规约串的选取、句柄-规范规约/最左素短语-算符优先级）</li><li>优先级分析法：优先关系表、算符文法（非终结符相邻）；算符优先文法OPG（不含<spanclass="math inline">\(\epsilon\)</span>规则、一种关系成立）</li><li>算符优先分析法不是一种规范归约的分析方法</li><li>最左素短语（<spanclass="math inline">\(\ge\)</span>一个终结符），不包含其他素短语</li><li>LR语法；LR分析表；移进/归约/接受/报错、规范句型活前缀、归约项目、移进项目、待约项目、接受项目；句柄识别态，接受状态，项目集规范族</li></ul><h2 id="题型与方法">题型与方法</h2><h3 id="左递归提取公因子">左递归/提取公因子</h3><p><strong>左递归的消除</strong> <span class="math display">\[A \rightarrowA\alpha_1|A\alpha_2|\dots|A\alpha_m|\beta_1|\beta_2|\dots|\beta_n\]</span> 修改为： <span class="math display">\[A \rightarrow \beta_1A&#39;|\beta_2A&#39;\dots|\beta_nA&#39;\\A&#39;\rightarrow\alpha_1A&#39;|\alpha_2A&#39;|\dots|\alpha_mA&#39;|\epsilon\]</span> <strong>提取公因子</strong> <span class="math display">\[A\rightarrow \alpha\beta_1|\alpha\beta_2|\dots|\alpha\beta_n\]</span> 提取后得到： <span class="math display">\[A\rightarrow aA&#39;\\A&#39; \rightarrow \beta_1|\beta_2|\dots|\beta_n\]</span></p><blockquote><p>将非LL(1)转为LL（1）的过程中可能会遇到隐式公共左因子，需要先代入</p></blockquote><h3 id="ll1文法的判定">LL(1)文法的判定</h3><p><strong>FIRST集合</strong></p><p>由<spanclass="math inline">\(\alpha\)</span>可以推导出所有的首终结符或者可能的<spanclass="math inline">\(\epsilon\)</span></p><p><strong>FOLLOW集合</strong></p><p>A后面的所有终结符或<span class="math inline">\(\$\)</span></p><p><strong>SELECT集合</strong> <span class="math display">\[SELECT(A\rightarrow \alpha)=\begin{cases}FIRST(\alpha)&amp;,a\nRightarrow \epsilon\\FIRST(\alpha)\setminus{\epsilon}\cup FOLLOW(A)&amp;,a\xRightarrow{*}\epsilon\end{cases}\]</span> <strong>判断条件</strong> <span class="math display">\[SELECT(A\rightarrow \alpha)\cap SELECT(A\rightarrow \beta)=\Phi\]</span></p><h3 id="预测分析法">预测分析法</h3><p><strong>预测分析表的构造</strong></p><blockquote><p>首先需要判断是否为LL(1)文法</p></blockquote><ol type="1"><li>计算<span class="math inline">\(FIRST\)</span>集和<spanclass="math inline">\(FOLLOW\)</span>集</li><li><span class="math inline">\(A\rightarrow \alpha,\alpha \inFIRST(A)\)</span>，则<span class="math inline">\(M[A,a]=A\rightarrow\alpha\)</span></li><li><span class="math inline">\(\epsilon \in FIRST(A)\)</span>则对<spanclass="math inline">\(\forall b\in FOLLOW(A),M[A,b]=A\rightarrow\alpha\)</span></li><li>未定义内容用空白格表示</li></ol><p><strong>预测分析表作用于预测分析器</strong></p><p><imgsrc="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406181526458.png"alt="image-20240618152650413" /></p><h3 id="算符优先级分析法">算符优先级分析法</h3><p><strong>终结符优先级的定义</strong></p><ul><li><span class="math inline">\(a=b: P\rightarrow\dotsab\dots\)</span>或<span class="math inline">\(P\rightarrow\dotsaQb\dots\)</span></li><li><span class="math inline">\(a\lessdot b:P\rightarrow \dotsaR\dots\)</span>且<spanclass="math inline">\(R\xRightarrow{+}Qb/b\dots\)</span></li><li><span class="math inline">\(a\gtrdot b:P\rightarrow \dotsRb\dots\)</span>且<spanclass="math inline">\(R\xRightarrow{+}aQ/a\dots\)</span></li><li>越包含在里面，在语法树中层级越偏下，优先级越高</li></ul><p><strong>构造FIRSTVT集</strong> <span class="math display">\[FIRSTVT(A)=\{b|A\xRightarrow{+}b\dots or A\xRightarrow{+}Bb\dots \}\]</span> <strong>构造LASTVT集</strong> <span class="math display">\[LASTVT(A)=\{a|A\xRightarrow{+}\dots a or A\xRightarrow{+}\dots aB \}\]</span> <strong>构造表格</strong></p><ul><li><p>终结符在左，非终结符在右：终结符<spanclass="math inline">\(\lessdot\)</span>非终结符的<spanclass="math inline">\(FIRSTVT\)</span>集</p></li><li><p>终结符在右，非终结符在左：非终结符的<spanclass="math inline">\(LASTVT\)</span>集<spanclass="math inline">\(\lessdot\)</span>终结符</p></li><li><p>终结符在左右-&gt;相等</p></li><li><p>对于S，<span class="math inline">\(\$\lessdot FIRSTVT,LASTVT\gtrdot\$,\$=\$\)</span></p></li></ul><p><strong>最左素短语的判断</strong></p><p>(太困了，不想写)</p><p><imgsrc="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406181628811.png"alt="image-20240618162834778" /></p><ul><li>左右的非终结符也属于素短语</li></ul><p><strong>分析过程</strong></p><p><imgsrc="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406181638576.png"alt="image-20240618163841540" /></p><h3 id="lr0的构造">LR(0)的构造</h3><p><strong>主要内容</strong></p><ul><li><strong>CLOSURE的构造</strong>（后一个非终结符的展开）</li><li><strong>GO函数构造</strong>（点的移动+闭包构造）</li><li>重复GO直至不出现新的状态集</li></ul><p><strong>LR分析表的构造</strong></p><ol type="1"><li>用0~n表示初始状态</li><li>ACTION：未结束且接受终结符</li><li>GOTO：接受非终结符</li><li>ACTION<spanclass="math inline">\(r_j\)</span>：已经可归约；终结符或结束符纪</li><li>acc：S结束，相对于<span class="math inline">\(\$\)</span></li></ol><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406182129272.png" alt="image-20240618212900201" style="zoom:80%;" /></p><h3 id="slr1文法">SLR(1)文法</h3><ul><li>在状态中又有移进项目，又有归约项目</li><li>比LR(0)多求一个FOLLOW集</li><li>将reduce行求出对应文法FOLLOW集，只给FOLLOW集写reduce即可</li></ul><p><strong>怎么确定SLR(1)</strong></p><p>符号和FOLLOW集交集是否为空串</p><h3 id="lr1文法">LR(1)文法</h3><p><strong>寻找向前搜索符</strong></p><ul><li>为空，照抄</li><li>不为空，加入FIRST集</li></ul>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
          <category> class </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> 2023-2024Spring </tag>
            
            <tag> compiling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIS2334</title>
      <link href="/2024/06/02/NIS2334/"/>
      <url>/2024/06/02/NIS2334/</url>
      
        <content type="html"><![CDATA[<div class="note success modern"><p>可能考点！！！！！！</p></div><p>1.计算题：</p><ul><li>扇区读写时间</li><li>信号量</li><li>周转时间</li></ul><p>2.重点</p><ul><li>概述<ul><li>spooling</li><li>缓冲/中断/DMA</li><li>操作系统的特征</li><li>操作系统的功能</li><li><a href="1">操作系统的概念</a></li><li>并发</li><li>脱机/假脱机</li></ul></li><li>进程和线程<ul><li>进程调度算法</li><li>线程基本理解（用户级、内核级、混合级）</li><li>同步和互斥</li><li>调度层次</li><li>进程思索条件</li><li>调度死锁处理：银行家、coffman</li><li>生产者-消费者程序</li><li>PV操作</li></ul></li><li>内存管理<ul><li>局部性原理，对虚拟分段、多级分页、虚拟分页、虚拟段页式影响</li><li>虚拟地址与物理地址转换</li><li>多级页表</li><li>系统抖动及页面淘汰算法</li></ul></li><li>设备和文件<ul><li>机械盘为什么慢</li><li>磁盘调度</li><li>node，文件大小</li><li>打开文件接口，文件控制表</li><li>IO标准库</li></ul></li><li>综合<ul><li>局部性原理</li><li>中断处理程序、信号、陷阱</li></ul></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><ul><li><p>方便：作为用户/计算机<u>接口</u>的操作系统</p></li><li><p>有效：作为<u>资源管理器</u>的操作系统</p></li><li>扩展能力：操作系 统的<u>易扩展性</u><ul><li><u>硬件</u>升级、新型硬件</li><li><u>新服务</u></li><li><u>纠正</u>错误（打补丁）</li></ul></li></ul><h3 id="地位和作用"><a href="#地位和作用" class="headerlink" title="地位和作用"></a>地位和作用</h3><ul><li><u>屏蔽</u>底层硬件的细节</li><li><u>驱动、管理</u>硬件设备</li><li>给<u>应用程序</u>提供服务</li></ul><h3 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a><a id="1">操作系统概念</a></h3><ul><li>用户观点——用户使用计算机的<strong>界面</strong><ul><li>命令方式</li><li>系统调用</li><li>图形界面</li></ul></li><li>软件观点——程序和数据结构的集合<ul><li>系统工具:shell、系统管理</li><li>OS库（I/O）</li></ul></li></ul><blockquote><p>操作系统是<strong>控制和管理计算机系统内各种硬件和软件资源</strong>、有效地<strong>组织多道程序运行</strong>的<strong>系统软件</strong>（或程序集合），是用户与计算机之间的接口。</p><ul><li>是软件，且是<strong>系统软件</strong></li><li>基本职能是<strong>控制和管理</strong>系统资源</li><li><strong>提供服务</strong>，方便用户使用</li></ul></blockquote><h3 id="作业与进程"><a href="#作业与进程" class="headerlink" title="作业与进程"></a>作业与进程</h3><p><strong>作业</strong></p><ul><li>作业（一个<strong>完整</strong>的任务，可能包括<font color="red">多个程序</font>）</li><li>作业步（作业中<u>相对独立</u>的部分）</li></ul><p><strong>进程</strong></p><ul><li>UNIX系统上的进程定义为程序在一个<u>数据集合</u>上的<strong>运行活动</strong>，它是<strong>系统进行资源分配和调度的一个可<font color="red">并发</font>执行的独立单位</strong>。进程和程序之间既有区别又有联系。</li></ul><h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a><a id="3">操作系统的特征</a></h3><p><strong>并发</strong>（Concurrence）</p><ul><li>在一段时间内，多个程序同时在运行。</li><li><strong><font color="red">并发与并行的区别</font></strong></li></ul><blockquote><p><strong>任务执行方式：</strong></p><ul><li><strong>并行：</strong> 并行处理要求系统具有<u>多个处理单元</u>，这些单元可以同时执行不同的任务。每个任务都在独立的处理单元上运行，彼此之间互不干扰。这种方式能够<u>充分利用硬件资源，加速任务的完成</u>。</li><li><strong>并发：</strong> 并发处理强调任务的<u>交替执行或重叠执行</u>。即使系统只有一个处理单元，也可以通过任务间的切换，使得看似同时运行多个任务。并发更关注<u>任务之间的协作和调度</u>，以确保系统的效率和响应性。</li></ul><p><strong>目标：</strong></p><ul><li><strong>并行：</strong> 并行的主要目标是通过<u>同时执行多个任务</u>来提高整体性能。这通常涉及到将大任务划分为小的子任务，每个子任务由不同的处理单元执行，最终合并它们的结果。</li><li><strong>并发：</strong> 并发的目标是<u>更好地管理多个任务</u>之间的关系，以确保它们能够有效地协同工作。并发处理通常用于处理实时性要求不高的任务，强调任务之间的逻辑结构和相互影响。</li></ul></blockquote><p><strong>共享</strong>（Sharing）</p><ul><li>互斥共享：打印机，写数据</li><li>同时共享：磁盘，只读数据</li></ul><p><strong>虚拟</strong></p><ul><li>目的：为裸机提供高级抽象服务，虚拟出功能更强大的虚拟服务。</li><li><strong>例子：分时系统；SPOOLING</strong></li></ul><p><strong>不确定性</strong></p><ul><li>同样一个数据集的同一个程序在<u>同样的计算机环境</u>下运行，其执行<u>顺序</u>和<u>所需时间</u>都不相同。</li></ul><h3 id="现代操作系统的新特征"><a href="#现代操作系统的新特征" class="headerlink" title="现代操作系统的新特征"></a>现代操作系统的新特征</h3><details>    <summary>现代操作系统的新特征</summary>    <p><strong>微内核体系结构：</strong>微内核体系结构将操作系统的基本功能（如内存管理、进程管理、通信等）最小化，并将其他功能移到用户空间。这种设计提高了系统的可扩展性和稳定性，因为内核的代码量减少，从而降低了出错的可能性。</p>    <p><strong>多线程：</strong>多线程允许一个进程内的多个线程并行执行，每个线程共享进程的资源但有独立的执行路径。这提高了应用程序的响应速度和处理能力，尤其在多处理器系统中表现尤为明显。</p>    <p><strong>对称多处理（SMP）：</strong>对称多处理支持多个处理器共享同一内存和I/O资源，处理器之间可以并行执行任务。这种架构简化了多处理器系统的设计和实现，提升了系统的性能和扩展能力。</p>    <p><strong>分布式：</strong>分布式操作系统使得资源和服务可以分布在多个网络节点上，并通过网络进行协作。它提供了对分布式计算资源的统一管理和访问，使得用户和应用程序能够透明地使用远程资源。</p>    <p><strong>面向对象设计：</strong>面向对象设计方法将系统功能和资源抽象为对象，通过继承和多态性提高了代码的重用性和可维护性。现代操作系统利用这种设计方法简化了系统的扩展和修改。</p></details><h4 id="微内核体系结构"><a href="#微内核体系结构" class="headerlink" title="微内核体系结构"></a><strong>微内核体系结构</strong></h4><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406100039550.png" alt="image-20240610003916511" style="zoom:50%;" caption="微内核体系示意图"/></p><p><strong>单体内核（monolithic kernel）</strong></p><ul><li>系统由<u>大内核</u>构成，该内核提供的功能<u>：调度、文件系统、网络、设备驱动程序、存储管理</u>等</li><li>大内核作为<u>一个进程</u>实现，所有元素<u>共享相同的地址空间</u></li></ul><p><strong>微内核（micro kernel）</strong></p><ul><li>内核仅具有基本功能：<u>地址空间、进程通信和基本调度</u>。</li><li>‘其他的操作系统服务都由运行在<u>用户模式</u>下<u>进程</u>提供。</li><li>优点：<ul><li>内核和服务分开，可以<u>订制服务</u>；</li><li>体系结构更简单灵活，适合于<u>分布式环境</u></li></ul></li></ul><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a><strong>多线程</strong></h4><ul><li><strong>线程</strong>：可分派<u>工作单元</u>。包括：处理器上下文、栈中自己的数据区域。</li><li><strong>进程：</strong>一个或多个线程及其相关<u>系统资源的集合</u>。</li><li><strong>优点：</strong><ul><li>方便处理<strong>独立</strong>任务（如监听服务）</li><li>线程间<strong>切换开销小</strong></li></ul></li></ul><details>    <summary>线程和进程的区别</summary>    <p><strong>定义：</strong></p>    <ul>        <li><strong>进程（Process）：</strong>进程是程序的一次执行实例，是操作系统进行资源分配和调度的基本单位。每个进程都有独立的内存空间和系统资源。</li>        <li><strong>线程（Thread）：</strong>线程是进程内的一个执行单元，是程序执行的最小单位。线程共享进程的内存空间和资源，但有独立的执行路径和局部变量。</li>    </ul>    <p><strong>内存空间：</strong></p>    <ul>        <li><strong>进程：</strong>每个进程有独立的地址空间，一个进程崩溃不会影响其他进程。</li>        <li><strong>线程：</strong>同一进程内的线程共享相同的地址空间，一个线程崩溃可能导致整个进程崩溃。</li>    </ul>    <p><strong>通信方式：</strong></p>    <ul>        <li><strong>进程：</strong>进程之间的通信需要通过操作系统提供的进程间通信（IPC）机制，如管道、消息队列、共享内存等。</li>        <li><strong>线程：</strong>线程之间可以直接通过共享内存进行通信，通信开销较低。</li>    </ul>    <p><strong>资源开销：</strong></p>    <ul>        <li><strong>进程：</strong>创建和销毁进程的开销较大，因为需要分配和回收独立的内存和资源。</li>        <li><strong>线程：</strong>创建和销毁线程的开销较小，线程间切换的开销也比进程间切换小。</li>    </ul>    <p><strong>调度：</strong></p>    <ul>        <li><strong>进程：</strong>操作系统独立调度进程，每个进程可以在不同的处理器上运行。</li>        <li><strong>线程：</strong>操作系统独立调度线程，同一进程内的线程也可以在不同的处理器上运行，支持并行执行。</li>    </ul>    <p><strong>应用场景：</strong></p>    <ul>        <li><strong>进程：</strong>适用于需要强隔离、独立运行的任务，如不同的应用程序。</li>        <li><strong>线程：</strong>适用于需要高效并发、共享数据的任务，如多线程服务器、并行计算。</li>    </ul></details><h4 id="对称多处理SMP"><a href="#对称多处理SMP" class="headerlink" title="对称多处理SMP"></a>对称多处理SMP</h4><p><strong>基本要求</strong>：</p><ul><li>多个处理器</li><li>共享<strong>主存储器和IO设备</strong></li><li>处理器都可以执行<strong>相同</strong>的功能</li></ul><p><strong>优势</strong></p><ul><li>性能（优于单处理器）</li><li>可用性（鲁棒性）</li><li>（性能）可增量发展</li><li>（产品）可扩展性</li></ul><details>    <summary>为什么SMP具有产品可扩展性</summary>    <p><strong>共享内存架构：</strong></p>    <ul>        <li><strong>简单易扩展：</strong> SMP系统中的所有处理器共享同一块物理内存和I/O设备。当增加新的处理器时，只需将其连接到共享内存总线上，无需改变现有系统的架构和数据流。</li>        <li><strong>一致性和简单性：</strong> 共享内存模型使得所有处理器都能访问相同的内存地址空间，这简化了开发和调试过程，因为程序员可以依赖于内存的一致性。</li>    </ul>    <p><strong>并行处理能力：</strong></p>    <ul>        <li><strong>提高性能：</strong> 通过增加更多的处理器，SMP系统可以并行处理更多任务，提高系统的整体性能和吞吐量。增加处理器的过程相对直接，只需配置新的处理器即可。</li>        <li><strong>负载均衡：</strong> SMP操作系统能够智能地将任务分配给不同的处理器，确保系统资源得到充分利用，并防止某个处理器过载。这种动态负载均衡能力使得系统能平稳扩展。</li>    </ul>    <p><strong>标准化和兼容性：</strong></p>    <ul>        <li><strong>硬件兼容性：</strong> SMP系统通常使用标准化的硬件组件，如通用的处理器和内存模块。这种标准化的设计使得添加新处理器变得简单且具有成本效益。</li>        <li><strong>软件兼容性：</strong> SMP操作系统和应用软件通常设计为支持多处理器环境，这意味着现有的软件可以在扩展后的SMP系统上无缝运行，无需进行重大修改。</li>    </ul>    <p><strong>容错能力和可靠性：</strong></p>    <ul>        <li><strong>高可用性：</strong> 通过冗余配置多个处理器，SMP系统可以在某个处理器故障时继续运行，提升系统的可靠性和容错能力。增加处理器可以进一步增强这种容错能力。</li>        <li><strong>简化维护：</strong> 由于处理器是模块化的组件，扩展和更换处理器变得相对简单，维护和升级也更加方便。</li>    </ul>    <p><strong>经济效益：</strong></p>    <ul>        <li><strong>成本效益：</strong> 由于SMP系统采用标准化组件，扩展系统的成本相对较低。企业可以根据需要逐步增加处理器，而不必一次性投入大量资金。</li>        <li><strong>灵活投资：</strong> 企业可以根据实际需求逐步扩展处理能力，而无需提前为未来的需求进行大量投资，这种灵活性有助于降低初始成本和投资风险。</li>    </ul></details><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p>多机系统好像具有一个<strong>单一的主存空间</strong>、<strong>辅存</strong>空间以及其他<strong>统一</strong>的<strong>存取</strong>措施。</p><details>    <summary>现代操作系统的分布式特征</summary>    <p><strong>资源共享：</strong> 现代分布式操作系统能够管理和协调分布在不同网络节点上的资源，使得这些资源可以在整个网络中共享和访问。这包括处理能力、存储资源、数据和设备等。</p>    <p><strong>透明性：</strong> 分布式操作系统隐藏了系统的分布性和复杂性，使得用户和应用程序可以像访问本地系统一样访问分布式系统的资源和服务。透明性包括位置透明性、访问透明性、迁移透明性和复制透明性等。</p>    <p><strong>可靠性和容错性：</strong> 通过冗余和故障检测机制，分布式操作系统可以在某些节点或资源发生故障时继续提供服务，从而提高系统的可靠性和容错性。这通常包括数据备份、自动故障恢复和负载均衡等。</p>    <p><strong>并行处理：</strong> 分布式操作系统支持并行处理，通过将任务分割成多个子任务并分配给不同的节点执行，从而提高系统的处理能力和效率。这对于大规模计算和复杂数据处理任务尤为重要。</p>    <p><strong>扩展性：</strong> 分布式操作系统可以通过增加新的节点来扩展系统的容量和性能，支持应对不断增加的用户请求和数据处理需求。系统能够动态添加或移除节点，保持系统性能和资源的高效利用。</p>    <p><strong>一致性和协调：</strong> 分布式操作系统提供一致性协议和协调机制，以保证分布式环境中数据的一致性和操作的同步。常用的一致性模型包括强一致性、最终一致性等。</p>    <p><strong>分布式文件系统：</strong> 分布式操作系统通常包含分布式文件系统，使得文件可以跨越多个节点存储和访问，从而提高数据的可用性和可靠性。用户可以透明地访问和管理分布式文件。</p></details><h4 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h4><p><strong>特点</strong></p><ul><li>方便地<strong>添加模块</strong></li><li>方便<strong>定制</strong>操作系统</li><li>促进了<strong>分布式</strong>工具和分布式操作系统的开发。</li></ul><h2 id="缓冲、中断与DMA"><a href="#缓冲、中断与DMA" class="headerlink" title=" 缓冲、中断与DMA "></a><a id="4"> <u>缓冲、中断与DMA</u> </a></h2><h3 id="主要解决问题"><a href="#主要解决问题" class="headerlink" title="主要解决问题"></a>主要解决问题</h3><ul><li><strong>缓冲技术</strong><ul><li>处于CPU 和 外设之间， 解决速度不匹配问题</li><li>例如，spooling</li></ul></li><li><strong>中断技术</strong><ul><li>解决 CPU 和 外设的协调</li><li>(不再需要轮询外设状态)</li></ul></li><li><strong>DMA技术</strong><ul><li>数据转移过度消耗CPU资源的问题，进一步解放CPU</li></ul></li></ul><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><ul><li>现代所有CPU都支持中断</li><li>用于<strong>提高处理器的利用率</strong></li></ul><blockquote><p>不同类型</p><ul><li>I/O</li><li>硬件错误、失效</li><li>软件错误（栈溢出、非法指令等）</li><li>定时器中断</li></ul></blockquote><h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><ul><li>驱动程序设定传输<u>数据的长度、源地址与目的地址</u></li><li>Device<u>启动DMA传输</u>，完成所有数据的传输</li><li>数据传输完成时DMA 设备<strong>产生中断</strong></li></ul><blockquote><p><strong>基本原理</strong></p><p>DMA技术的基本原理是将数据传输的控制交给一个专门的DMA控制器，该控制器不需要CPU的干预，可以直接对<u>内存和I/O设备</u>进行访问和传输。这个过程中，CPU只需启动DMA控制器，并在数据传输完成后<u>得到一个中断信号</u>，表明数据已经传输完毕。这样就可以达到高效率、低CPU负载的目的</p><p><strong>优点</strong></p><ul><li>把比较固定的任务让DMA来做，可以减轻<strong>CPU</strong>负担，提高系统的效率</li><li>DMA具有一般CPU没有的高效操作，提高系统的<strong>吞吐率</strong>；消除了每次只能传输一个数据的限制，<strong>传输效率</strong>提高</li></ul></blockquote><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><details>    <summary>批处理概述</summary>    <p>批处理是一种计算机操作系统中的自动化技术，用于批量处理多个命令或任务。其主要特点包括：</p>    <ul>        <li><strong>自动化执行：</strong>批处理允许用户将一系列的命令或任务按顺序组织在一个批处理文件中，然后通过执行该文件来自动化执行这些命令，而无需用户手动逐个输入和执行。</li>        <li><strong>批量处理：</strong>通过批处理，用户可以一次性处理多个任务或操作，这些任务可以是复制文件、备份数据、运行程序等，从而提高操作效率和减少手动操作的重复性。</li>        <li><strong>脚本语言支持：</strong>通常使用特定的脚本语言编写批处理文件，如Windows中的批处理文件（.bat文件）或Linux/Unix中的Shell脚本，这些脚本语言提供了控制流程、变量、循环等编程结构，使得批处理更加灵活和强大。</li>        <li><strong>批处理调度：</strong>批处理可以通过系统的调度器（如Windows任务计划程序）定时执行，也可以在特定条件满足时触发执行，从而实现自动化的后台任务管理。</li>    </ul>    <p>总体而言，批处理技术通过自动化和批量处理的方式，帮助用户简化和加快了日常计算机操作和管理任务的执行过程。</p></details><h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h3><p>进一步提高CPU的利用率</p><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406092227686.png" alt="image-20240609221806194" style="zoom:67%;" /></p><p><strong>基本原理</strong></p><p>​    允许<u>多个程</u>序（作业）同时进入一个计算机系统的内存并启动进行<strong>交替计算</strong>的方法，也就是，计算机中可以同时存放多道程序，<u>从宏观上来看它们是并行的，多道程序都同时处于运行过程中，但都未运行结束，但是微观上是串行的，轮流占用CPU交替执行</u>，引入多道程序设计技术的根本目的是提高CPU的利用率，充分发挥计算机系统部件的并行性</p><h4 id="总结利弊"><a href="#总结利弊" class="headerlink" title="总结利弊"></a>总结利弊</h4><ul><li>提高了<strong>CPU</strong>的利用率</li><li>提高了<strong>内存和I/O设备</strong>的利用率</li><li>改进了系统的<strong>吞吐率</strong></li><li>充分发挥了系统的<strong>并行性</strong></li><li>主要缺点是<strong>延长了作业周转时间</strong></li></ul><h3 id="SPOOLING"><a href="#SPOOLING" class="headerlink" title="SPOOLING"></a><a id="2">SPOOLING</a></h3><p><strong>为什么需要SPOOLING</strong></p><ul><li>受限于IO的作业，<u>输出缓冲</u>满，而输入空</li><li>受限于CPU的作业，<u>输入缓冲区</u>满，而输出空</li></ul><blockquote><p><strong>什么是SPOOLing技术</strong><br>SPOOLing 技术就是利用多道程序中的一道程序来模拟<strong>脱机输入时的外围控制机</strong>的功能，<strong>把低速 I/O 设备上的数据传送到高速磁盘上</strong>；用另一道程序来模拟<strong>脱机输出时外围控制</strong>机的功能，把<u>数据从磁盘传送到低速输出设备上</u>。这样，便在主机的直接控制下，实现脱机输入、输出功能。此时的外围操作与 CPU 对数据的处理同时进行，这种在联机情况下实现的同时外围操作称为 SPOOLing ，或称假脱机操作。</p><p><strong>优点</strong></p><ul><li>提高了<strong>I/O速度</strong>。从对低速I/O设备进行的I/O操作变为对输入井或输出井的操作，如同脱机操作一样，提高了I/O速度，缓和了CPU与低速I/O设备速度不匹配的矛盾。</li><li>将独占设备改造为<strong>共享设备</strong>。因为在SPOOLing系统的系统中，实际上<u>并没为任何进程分配设备，</u>而只是<u>在输入井或输出井中为进程分配一个<strong>存储区</strong>和建立一张<strong>I/O请求表</strong></u>。这样，便把独占设备改造为共享设备。</li><li>实现了<strong>虚拟设备</strong>功能。多个进程同时使用一独享设备，而对每一进程而言，都认为自己独占这一设备，从而实现了设备的虚拟分配。不过，该设备是<u>逻辑上的设备</u></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406092227549.png" alt="image-20240609222602484" style="zoom:50%;" /></p><p><strong>案例</strong></p><ul><li><p>将独享打印设备，变成多个程序共享的虚拟设备</p></li><li><p>工作方法:</p><p>系统对于用户的打印输出，但并不真正把打印机分配给该用户进程，而是先在输出井中申请一个<u>空闲盘块区</u>，并将要打印的数据送入其中；然后为用户<u>申请并填写请求打印表</u>，将该表挂到请求打印队列上。若打印机空闲，输出程序从请求打印队首取表，将要打印的数据从输出井传送到<u>内存缓冲区</u>，再进行打印，直到打印队列为空。</p></li></ul><h2 id="现代操作系统类型"><a href="#现代操作系统类型" class="headerlink" title="现代操作系统类型"></a>现代操作系统类型</h2><h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h3><p><strong>概念</strong></p><p>分时主要指若干并发程序对<u>CPU时间的共享</u></p><p><strong>优点</strong></p><p>响应快界面友好、多用户便于普及、便于资源共享</p><p><strong>与批处理多道程序设计的比较</strong></p><div class="table-container"><table><thead><tr><th></th><th>批处理多道程序设计</th><th>分时系统</th></tr></thead><tbody><tr><td>设计目标</td><td>充分使用<strong>处理器</strong></td><td>减少响应时间</td></tr><tr><td>指令源</td><td><u>作业控制语言</u>，作业命令</td><td>终端键入的命令</td></tr></tbody></table></div><p><strong>基本特征</strong></p> <details>         <summary>多路性（Multiprogramming）</summary>         <p>系统能够同时处理多个任务，使得多个用户能够同时使用系统资源。每个任务都在独立的虚拟环境中运行，互不干扰。</p>     </details>          <details>         <summary>独立性（Independence）</summary>         <p>每个用户的任务在系统中是相互独立的，彼此不会互相干扰或依赖。每个用户可以在系统中运行自己的程序，而不受其他用户程序的影响。</p>     </details>          <details>         <summary>交互性（Interactivity）</summary>         <p>用户能够与系统进行实时的交互操作。他们可以通过终端或其他输入设备输入命令、请求数据，系统能够及时响应并返回结果给用户。</p>     </details>          <details>         <summary>及时性（Timeliness）</summary>         <p>系统能够在合理的时间内响应用户的请求和任务，保证系统资源的有效利用和用户体验的流畅性。响应时间应该足够快，以便用户感觉不到延迟。</p>     </details><h3 id="实时系统"><a href="#实时系统" class="headerlink" title="==实时系统=="></a>==实时系统==</h3><p><strong>特点</strong>：</p><font color="red">响应时间很快</font>、可以在毫秒甚至微秒，在限定时间内响应**应用**：<font color="red">**过程控制**系统、**信息查询**系统、**事务处理**系统</font><p><strong>分类</strong>：</p><ul><li>硬实时系统</li><li>软实时系统</li></ul><p><strong>与分时系统区别：</strong></p><font color="red"><u>交互能力</u>较弱，<u>系统专用</u>，响应时间更严格，<u>及时可靠性</u>要求更高</font><h3 id="微机操作系统"><a href="#微机操作系统" class="headerlink" title="微机操作系统"></a>微机操作系统</h3><p><strong>单用户系统</strong></p><p>资源独享，<strong>不支持</strong><u>批处理、多任务、多道程序设计</u></p><p><strong>用于工作站的系统</strong></p><ul><li><font color="red">单用户使用</font></li><li>支持多道程序设计</li></ul><p><strong>用于服务器的系统</strong></p><ul><li><font color="red">支持多用户</font></li><li>支持多道程序设计</li><li>实例：Unix以及微软的所有系统</li></ul><h3 id="多处理机系统"><a href="#多处理机系统" class="headerlink" title="多处理机系统"></a>多处理机系统</h3><ul><li>由于受<u>电磁技术</u>的限制，单处理机<u>系统速度</u>受到限制，因此，需要多处理机系统</li></ul><p><strong><font color="red">分类</font></strong></p><ul><li>主从式</li><li>对称式</li></ul><details>    <summary>多处理机系统概述</summary>    <p>多处理机系统可以根据架构的不同分为对称式多处理机（SMP）和主从式多处理机两种：</p>    <p><strong>对称式多处理机（SMP）：</strong>所有处理器共享同一主存储器，每个处理器都可以访问共享的主存储器和I/O设备。处理器具有相同的权限和能力，可以独立执行任务，并通过共享总线或交叉开关进行通信。</p>    <p><strong>主从式多处理机：</strong>有一个或多个主处理器负责调度和协调系统中的其他从处理器。主处理器负责分配任务和资源，从处理器执行指定的计算任务，通常只能访问局部内存。</p>    <p>选择适当的多处理机架构取决于应用的性能需求、系统复杂性和成本考量。</p></details><h3 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h3><ul><li><p>网络操作系统是在各种各样自治的计算机原有操作系统基础上，加上具有<strong>网络访问功能</strong>的模块形成的。这些模块使网络上的计算机能方便、有效地<strong>共享网络资源</strong>，实现各种<strong>通信服务</strong>的有关协议。</p></li><li><p>网络操作系统<strong>不是</strong>一个<u>集中、统一</u>的操作系统。</p></li></ul><p><strong>特征</strong>：</p><font color="red">分布性、自治性、互连性、可见性</font><details>    <summary>网络操作系统特点</summary>    <p><strong>分布性：</strong>网络操作系统能够管理和协调分布在不同网络节点上的资源和服务，使得这些资源和服务可以在整个网络中共享和访问。</p>    <p><strong>自治性：</strong>网络操作系统中的每个节点都可以独立运行和管理自身的资源，具有自主的操作和处理能力。</p>    <p><strong>互连性：</strong>网络操作系统通过网络协议和通信机制连接不同的节点，使得它们可以进行数据交换和协同工作，形成一个统一的系统。</p>    <p><strong>可见性：</strong>网络操作系统提供了对网络中资源和服务的可见性，使得用户和应用程序可以发现、访问和利用网络中的各种资源。</p></details><h3 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h3><p><strong>概念</strong></p><ul><li>多计算机系统：<u>地理</u>位置不同，软硬件资源不同</li><li>具有一个<strong>统一的操作系统</strong>：分配<u>子任务</u>，<u>调度</u>，管理资源，<font color="red">对用户透明</font></li></ul><p><strong>特征</strong></p><font color="red">分布式处理、模块化结构、利用信息通信、实施整体控制</font><details>    <summary>分布式系统特征</summary>    <p><strong>分布式处理：</strong>分布式系统中的任务可以分布在多个节点或处理器上并行执行，从而提高系统的整体处理能力和效率。</p>    <p><strong>模块化结构：</strong>系统由多个相互独立的模块组成，每个模块负责不同的功能或服务，模块之间通过定义良好的接口进行通信和协作。</p>    <p><strong>利用信息通信：</strong>节点之间通过网络通信来进行数据传输和信息交换，实现节点之间的协调和合作。</p>    <p><strong>实施整体控制：</strong>尽管系统由多个分布式节点组成，但需要通过统一的控制和调度机制来管理和协调整个系统的运行，保证系统的一致性和可靠性。</p></details><p><strong>特点</strong></p><font color="red">透明性、灵活性、可靠性、高性能、可扩充性</font><details>    <summary>分布式系统特点</summary>    <p><strong>透明性：</strong>分布式系统隐藏了系统的分布性和复杂性，使得用户和应用程序可以像访问本地系统一样访问分布式系统的资源和服务。</p>    <p><strong>灵活性：</strong>分布式系统可以根据需求动态分配和管理资源，支持不同的应用程序和服务，并能够快速响应变化和增加新的节点。</p>    <p><strong>可靠性：</strong>分布式系统通过冗余和容错机制提高系统的可靠性，即使部分节点或资源出现故障，系统仍能保持正常运行。</p>    <p><strong>高性能：</strong>分布式系统利用并行处理和分布式计算能力，提高系统的整体性能和处理能力，能够处理大规模数据和复杂任务。</p>    <p><strong>可扩充性：</strong>分布式系统可以通过增加节点或资源来扩展系统的容量和性能，支持应对增加的用户请求和数据处理需求。</p></details><h2 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h2><h3 id="处理机管理（进程调度）"><a href="#处理机管理（进程调度）" class="headerlink" title="处理机管理（进程调度）"></a>处理机管理（进程调度）</h3><p><strong>原因</strong></p><p>在一段时间内，<font color="red">只能有一个进程</font>在CPU中执行</p><font color="red">**基本功能**</font><ul><li><u>作业和进程</u>调度</li><li>进程<u>控制</u></li><li>进程<u>通信</u></li></ul><blockquote><p> 同步方式和互斥方式；通信机制</p></blockquote><h3 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h3><p><strong>考虑因素</strong> </p><ul><li>速度</li><li>大小</li><li>成本</li></ul><font color="red">**基本功能**</font><ul><li>内存分配</li><li>地址映射（逻辑地址、物理地址）</li><li>内存保护（上界地址值、下界地址值）</li><li>内存扩充（虚拟存储技术）</li></ul><h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><p><strong>原因</strong></p><p>计算机外设<strong>种类众</strong>多，而且各种设备的<strong>传输速度差异很大</strong>，很难开发一种通用的、一致的解决方案。</p><p><strong>基本功能</strong></p><ul><li>缓冲区管理</li><li>设备分配</li><li>设备驱动</li><li>设备无关性</li></ul><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><blockquote><p>在大多数应用中,文件是一个核心成分,除了实时应用和一些特殊应用外,<strong>应用程序的输入都是通过文件来实现的</strong></p></blockquote><p><strong>基本功能</strong></p><ul><li>文件<strong>存储空间</strong>的管理</li><li>文件<strong>操</strong>作的一般管理</li><li><strong>目录</strong>管理</li><li>文件的<strong>读写</strong>管理</li><li><strong>存取控制</strong></li></ul><h3 id="附加功能服务"><a href="#附加功能服务" class="headerlink" title="附加功能服务"></a>附加功能服务</h3><p><strong>用户硬件接口</strong>:基本类型</p><ul><li>命令界面(DOS, Unix, windows命令行)</li><li><strong>程序界面(系统调用界面)</strong></li><li>图形界面(windows窗口, Linux的X-window)</li></ul><p><strong>网络</strong></p><p>TCP/IP…</p><p><strong>系统工具</strong></p><ul><li>shell: command line interface, ls, find/search,man</li><li>系统管理: ps,shutdown,mount,mkdir</li><li>软件开发: compilers, debuggers</li></ul><p><strong>OS 库</strong></p><ul><li>I/O: data buffering and formatting</li><li>Math: common utilities, APIs: (cos,sin,abs,sqrt)</li></ul><p><strong>信息保护与安全</strong></p><ul><li><strong>访问控制</strong><ul><li>只有经过授权的用户才能访问系统用户</li><li>只能访问属于自己的信息</li></ul></li><li><strong>信息流</strong><ul><li>限制系统中的信息流动方向</li></ul></li></ul><h2 id="关于UNIX和windows"><a href="#关于UNIX和windows" class="headerlink" title="关于UNIX和windows"></a>关于UNIX和windows</h2><ul><li><strong>SVR4</strong>是传统和现代版本的分水岭</li><li>传统unix结构<ul><li><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406100107701.png" alt="image-20240610010755653" style="zoom: 80%;" /></li></ul></li><li><p>Windows系统的特点：微内核结构、客户服务器模型、支持线程、SMP、面向对象</p></li><li><p>Solaris：可以在一个单独的Solaris内核实例中运行<u>创建并管理多个虚拟化</u>的操作系统，支持网际协议版本6（IPv6)，基于角色的访问控制（RBAC），支持32位的Intel x86</p></li><li>macOS：基于FreeBSD系统采用“面向对象操作系统”的全面的操作系统</li></ul><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="存储管理技术"><a href="#存储管理技术" class="headerlink" title="存储管理技术"></a>存储管理技术</h2><ul><li>单一连续区</li><li>固定分区<ul><li>大小相同</li><li>大小不同</li></ul></li><li>可变分区<ul><li>怎么管理：空闲分区表</li></ul></li></ul><h3 id="固定分区地址映射"><a href="#固定分区地址映射" class="headerlink" title="固定分区地址映射"></a>固定分区地址映射</h3><ul><li>固定定位</li><li>静态重定位</li><li>动态重定位</li></ul><h3 id="可变分区分配算法"><a href="#可变分区分配算法" class="headerlink" title="可变分区分配算法"></a>可变分区分配算法</h3><ul><li>首次适配<ul><li><strong>对应回收算法</strong></li></ul></li><li>循环首次适应算法</li><li>最佳适配</li><li><p>最差适配</p></li><li><p><strong>伙伴系统</strong></p></li></ul><h2 id="内存扩充技术"><a href="#内存扩充技术" class="headerlink" title="内存扩充技术"></a>内存扩充技术</h2><ul><li>覆盖</li><li>交换技术</li><li>多重分区<ul><li>简单分页</li></ul></li></ul><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="磁盘结构和调度"><a href="#磁盘结构和调度" class="headerlink" title="磁盘结构和调度"></a>磁盘结构和调度</h2><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><ul><li>控制器通过移动臂移动磁头读写磁道上的数据。<strong>每面</strong>都有独立的磁头</li><li>柱面: 所有盘片上的<strong>相同磁道</strong>组成柱面</li></ul><h3 id="磁盘时延"><a href="#磁盘时延" class="headerlink" title="磁盘时延"></a><font color="#CC0000">磁盘时延</font></h3><details>    <summary>具体计算</summary>    <img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/study/NIS2336/image-20240531151357537.png" alt="1"></details><ul><li><p>磁道优化</p><details>    <summary>优化方案</summary>    <ul>        <li>所有磁道上的BPI 相同(“固定位密度”)</li>        <li>磁盘容量更大</li>        <li>越靠外圈的磁道包含的扇区越多</li>        <li>磁盘转速固定，外磁道的速度比内磁道</li>    </ul></details></li></ul><h4 id="硬盘的使用"><a href="#硬盘的使用" class="headerlink" title="硬盘的使用"></a>硬盘的使用</h4><ul><li>硬盘必须分区</li><li>分区需用<u>某种文件系统</u>进行格式化</li><li>在某些情况下，可以用快速格式化取代完全格式化</li><li>为什么需要多分区</li><li><p>磁盘分布</p><ul><li>MBR（位置）、4个主分区、多个逻辑分区</li></ul></li></ul><h3 id="减少时延的方法："><a href="#减少时延的方法：" class="headerlink" title="减少时延的方法："></a>减少时延的方法：</h3><blockquote><p>缓存/</p><p>使用RAM磁盘/</p><p>RAID/</p><p>调度算法(读写头调度-&gt;调动磁头、元信息布置-&gt;怎么储存布置文件块)</p></blockquote><h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><ul><li><details>   <summary>关于高速缓存</summary>   <img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/study/NIS2336/20240531153644.png" alt="none"></details></li></ul><h4 id="替换策略："><a href="#替换策略：" class="headerlink" title="替换策略："></a><font color="#CC0000">替换策略</font>：</h4><ul><li>LRU</li><li>LFU</li><li>基于频率的替换算法<ul><li>优点：弱化集中访问对计数器的影响</li><li>具体实现：栈，计数器，新老两个区</li><li><img src="C:/Users/Windows11/AppData/Roaming/Typora/typora-user-images/image-20240603232956523.png" alt="image-20240603232956523" style="zoom:50%;" /></li><li>存在问题：新加入的块，如果很<u>快进入老区</u>，则没有竞争力，将很快被淘汰。</li></ul></li></ul><h4 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a><font color="#CC0000">磁盘调度</font></h4><ul><li>作用<ul><li>提高有效的<strong>数据吞吐率</strong></li><li>减少请求的<strong>平均等待时间</strong></li></ul></li><li>总结图<ul><li><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406032354849.png" alt="image-20240603235447821" style="zoom:80%;" /></li></ul></li><li><font color="red"> 常用调度策略</font></li><li><strong>FCFS</strong><ul><li>按请求的<u>时间顺序</u>，依次进行服务</li><li><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406032338650.png" alt="image-20240603233837629" style="zoom:80%;" /></li><li>优点：<ul><li>实现简单</li><li>有大量进程竞争时，在性能上接近于<strong>随机调度</strong></li></ul></li><li>缺点<ul><li><strong>寻道时间长</strong>，磁头<u>移动幅度大</u></li></ul></li><li>适合<strong>较轻负载</strong>的系统</li></ul></li><li><strong>SSTF最短寻道时间优先</strong><ul><li>优先响应寻道时间最短的请求</li><li><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406032343619.png" alt="image-20240603234311601" style="zoom:80%;" /></li><li>优点<ul><li><strong>寻道时间</strong>较短，<strong>服务效率</strong>较高，服务<strong>平均等待时间</strong>较短</li><li>提供比<u>FIFO</u>更高的效率</li></ul></li><li>缺点<ul><li><strong>公平性</strong>差，可能会出现服务请求长期得不到服务，甚至饿死</li><li><u>寻道时间</u>并不能真正实现最优。</li></ul></li><li>适合<strong>中度负载</strong>的系统</li></ul></li><li><strong>SCAN（电梯）算法</strong><ul><li>磁头<u>从一端出发向另一端移动</u>，移动过程中，发现有请求<u>对应磁头下的磁道</u>，就对该请求提供服务。到另一端后，开始反向移动，遇到请求进行服务</li><li><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406032347031.png" alt="image-20240603234757011" style="zoom:80%;" /></li><li>缺点：<ul><li>每个请求的等待时间不均匀，且<strong>平均等待时间</strong>长</li></ul></li><li>优化<ul><li><font color="blue">磁头并不是每次扫描都移动到最远的磁道上</font>，一旦在当前方向上前面没有请求，就开始反向移动。</li></ul></li><li>比较适合磁盘<strong>负载较重</strong>的系统</li></ul></li><li><strong>C-SCAN</strong><ul><li>类似电梯算法。但需要<strong>从零道开始</strong>。</li><li>磁头移动方向单一（从内到外）</li></ul></li><li>PRI进程优先级</li><li>LIFO（后进先出）<ul><li>局部性最好，资源利用率最高（等待时间少、缓存命中高）</li></ul></li><li>N-step-scan<ul><li>把请求分为<u>长度为N</u>的多个队列；一次处理一个队列；新到的请求加到其他队列中。</li><li>特性：<u>N较大时，等价于SCAN；N=1时，等价于FIFO</u></li></ul></li><li>FSCAN</li></ul><div class="note primary modern"><p>如何评价各个磁盘调度</p></div><ul><li>通常情况下，除非有很多请求在队列中，否则，各个算法<strong>没太大区别</strong></li><li>操作系统可以<strong>以执行效率为目的</strong>来按一定的策略放置文件<ul><li><strong>分布式系统</strong>把<u>频繁使用的文件</u>放在磁盘的中间位置</li><li><strong>Ext2文件系统</strong>把<u>inode节点</u>放在磁盘靠近他们所<u>表示的数据块</u>的附近。</li></ul></li></ul><h4 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h4><blockquote><p>作用</p><ul><li>通过<strong>并行</strong>提高性能</li><li>通过<strong>冗余</strong>提高可靠性</li></ul></blockquote><div class="note primary modern"><p>常用层次：RAID0,RAID1.RAID 5,RAID6</p></div><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406040007276.png" alt="image-20240604000729248" style="zoom:80%;" /></p><h3 id="磁盘调度器（Linux）"><a href="#磁盘调度器（Linux）" class="headerlink" title="磁盘调度器（Linux）"></a>磁盘调度器（Linux）</h3><h4 id="电梯调度器-Elevator"><a href="#电梯调度器-Elevator" class="headerlink" title="电梯调度器(Elevator)"></a>电梯调度器(Elevator)</h4><ul><li>使用电梯算法：队列以<strong>块号</strong>进行排序</li></ul><blockquote><p>有一个新的读写请求到达时，会依次考虑4个操作</p><ul><li>如果新请求与队列中的请求在<strong>同一磁盘扇区或相邻的扇区</strong>，则把新请求<strong>合并</strong>进队列</li><li>如果队列中的请求已经<strong>很长时间</strong>了，则新请求将被插入到<strong>队列尾部</strong></li><li>如果<strong>有合适位置</strong>，则新请求将被<strong>按顺序插入队列中</strong></li><li>如果<strong>没有合适的位置</strong>，则新请求将被插入队列的<strong>尾部</strong></li></ul></blockquote><font color="purple">什么叫“请求已经很长时间了”</font><h4 id="Linux-时限IO调度器"><a href="#Linux-时限IO调度器" class="headerlink" title="Linux-时限IO调度器"></a>Linux-时限IO调度器</h4><ul><li>作用：为了防止Linux Elevator出现<strong>长期延迟</strong>问题</li><li>采用3个队列：读请求同时存在于1，2队列中；写请求同时存在于1，3队列中<ul><li><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406040004661.png" alt="image-20240604000422642"></li></ul></li><li>读请求的<strong>默认时限</strong>是0.5秒，写请求5秒。</li></ul><h4 id="Linux-预期IO调度器"><a href="#Linux-预期IO调度器" class="headerlink" title="Linux-预期IO调度器"></a>Linux-预期IO调度器</h4><ul><li>对时限IO调度器的改进</li><li>根据“<strong>局部性</strong>”原理，磁盘请求往往相邻</li><li>当<strong>读请求</strong>被分派时，预期调度器的执行<u>将延迟6毫秒后再决定是否移动磁头到下一个位置</u></li></ul><h2 id="文件系统基本信息"><a href="#文件系统基本信息" class="headerlink" title="文件系统基本信息"></a>文件系统基本信息</h2><h3 id="早期不足"><a href="#早期不足" class="headerlink" title="早期不足"></a>早期不足</h3><details>    <summary>自行展开</summary>    <img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406040011374.png" alt="image-20240604001140344" style="zoom:67%;" /></details><blockquote><p>而后由个人向<strong>系统级</strong>发展，以系统调用的形式向应用程序提供<strong>数据管理服务</strong></p></blockquote><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>方便用户管理自己的数据资源</p><h4 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a><font color="red">基本要求</font></h4><ul><li>文件<strong>按名</strong>存储</li><li>文件有序组织，文件名<strong>分层次</strong>管理<ul><li>如支持树形目录结构</li></ul></li><li>操作简单，<strong>存取效率高</strong>。</li></ul><h4 id="其他要求"><a href="#其他要求" class="headerlink" title="其他要求"></a>其他要求</h4><ul><li>支持<strong>多用户系统</strong>，多用户能够<u>共享同一个磁介质</u></li><li>有一定的<strong>安全性</strong>保证，最好能进行<strong>数据恢复</strong></li><li>存储空间的<strong>利用率</strong>高</li></ul><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><strong>文件</strong>：由<u>文件名字</u>标识的一组相关信息的集合。<strong>文件名</strong>是<u>字母或数字</u>组成的字母数字串</li><li><strong>文件系统</strong>:<ul><li>软件观点：操作系统中，为用户和应用程序<u>管理文件</u>的<u>系统软件集合</u></li><li>存储格式观点：文件系统是文件在<u>存储介质上保存和管理相关的约定</u>。在操作系统中，这种约定的实现也被称为文件系统。一种相关约定就对应一种文件系统，所以目前存在多种文件系统：FAT，FAT32，NTFS，EXT2等</li></ul></li><li><strong>一个操作系统</strong>除支持为它设计的文件系统外，<strong>还可能支持其他文件系统</strong></li></ul><h4 id="文件的命名"><a href="#文件的命名" class="headerlink" title="文件的命名"></a>文件的命名</h4><ul><li>文件名是<strong>字母或数字</strong>组成的字母数字串，在一些文件系统中还可能包含其它字符，如<strong>下划线</strong>等</li><li>各种文件系统的文件命名规则略有不同，即文件名的<strong>格式和长度</strong>因系统而异。</li></ul><blockquote><p>长度包括文件路径</p></blockquote><h4 id="文件的类型"><a href="#文件的类型" class="headerlink" title="文件的类型"></a>文件的类型</h4><ul><li><strong>普通文件</strong>：即前面所讨论的<u>存储在外存设备上</u>的数据文件。</li><li><strong>目录文件</strong>：文件在管理普通数据文件时，需要保存其<u>相应的文件和属性</u>，这些属性以目录文件的形式存储在<u>磁盘</u>中。</li><li><strong>块设备</strong>文件：在<u>unix/Linux</u>等操作系统中，对应于<u>磁盘、光盘或磁带</u>等块设备的文件。</li><li><strong>字符设备</strong>文件：在<u>unix/Linux</u>等操作系统中，对应于终端、打印机等<u>字符设备</u>的文件</li></ul><h4 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h4><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406040026701.png" alt="image-20240604002658680" style="zoom:50%;" /></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>用户使用方便</strong>：只要知道文件名，可存取信息，实现了<u>“按名存取”</u></li><li><strong>安全可靠性</strong>：<ul><li>用户<u>通过文件系统才能</u>实现对文件的访问，故可防止对文件信息无意的破坏。</li><li>而文件系统能提供各种<u>安全、保密和保护</u>措施</li></ul></li><li><strong>数据共享</strong><ul><li>移动存储设备</li><li>各种形式的文件链接，不同的用户可以使用<u>同名或异名的同一文件</u></li></ul></li></ul><h1 id="设备管理-1"><a href="#设备管理-1" class="headerlink" title="设备管理"></a>设备管理</h1><div class="note primary modern"><p>如果没有设备管理会怎么样</p></div><ul><li>加重应用程序设计者的负担。</li><li>应用程序的<strong><font color="red">移植性</font></strong>比较差</li><li>设备<strong>利用率</strong>低</li></ul><h2 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h2><div class="note success modern"><p>设备概念</p></div><ul><li>进行<u>实际输入输出操作</u>的<strong>物理设备</strong></li><li><u>控制</u>物理设备的<strong>支持设备和支持部件</strong></li><li>为<u>提高利用率</u>，形成的<strong>逻辑设备</strong>和<strong>虚拟设备</strong>。</li></ul><blockquote><p>用高级编程语言操作的是什么设备</p><p>是逻辑设备哦</p></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="外在功能"><a href="#外在功能" class="headerlink" title="外在功能"></a>外在功能</h4><p>输入设备  //  输出设备 //  存储设备  //  供电设备  //  网络设备……</p><h4 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h4><ul><li>块设备</li><li>字符设备</li><li>流设备</li></ul><h4 id="存在形式"><a href="#存在形式" class="headerlink" title="存在形式"></a>存在形式</h4><ul><li>物理设备</li><li>逻辑设备</li></ul><h4 id="资源属性（OS管理）"><a href="#资源属性（OS管理）" class="headerlink" title="资源属性（OS管理）"></a>资源属性（OS管理）</h4><ul><li>共享设备</li><li>独占设备</li><li>虚拟设备</li></ul><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><ul><li>方便、统一的设备<u>使用界面</u>、</li><li>提高<strong>外部设备利用率</strong>，尽量提高<strong>并行程度</strong></li><li>实现<u>程序与设备</u>的<strong>无关</strong>性</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>设备的<strong>配置</strong>和<u>资源分配</u></li><li>设备的<strong>控制和驱动</strong></li><li>系统与设备之间的<strong>缓冲</strong></li><li>协调设备的<strong>调度和分配</strong></li></ul><h4 id="设备管理层次关系"><a href="#设备管理层次关系" class="headerlink" title="设备管理层次关系"></a>设备管理层次关系</h4><ol><li>底层通信（中断处理）<ul><li>实现软件和硬件设备的通信</li></ul></li><li>设备驱动<ul><li>接受来自<u>上层的抽象操作</u>请求，并负责操作的具体实施</li><li>主要组成：与设备打交道的软件、<u>共享支持、缓冲区支持</u>等</li></ul></li><li>对用户层的I/O接口<ul><li>每个I/O调用接口对应具体的<u>设备抽象操作</u></li></ul></li><li>使用设备的用户级程序<ul><li>通过调用所提供的接口来实现对设备的使用或控制</li></ul></li></ol><h2 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h2><blockquote><p><strong>硬件时钟</strong>：由<strong>硬件脉冲</strong>形成，经<strong>计数器和定时器</strong>产生定时中断。</p><p><strong>软件时钟</strong>：由<strong>程序模拟</strong>的时钟，可以产生<font color="red">软中断</font>。</p></blockquote><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul><li><strong>系统时钟</strong>（软时钟）：控制指令执行</li><li><strong>日历时钟</strong>（由软件根据<u>实时时钟</u>设置）</li><li><strong>实时时钟</strong> (Real-time clock): 提醒处理器有其他事情要做（也就是产生<u>硬件中断</u>）</li></ul><div class="note success modern"><p>系统时钟的维护</p></div><p>在计算机<strong>没有启动</strong>时。<u>主板</u>上包含了一个类似<u><strong>石英钟</strong>的物理时钟</u>在记录时间的流逝和变化</p><p>系统<strong>启动</strong>时，OS从<u>物理时钟</u>读取当前时间，保存在<u>全局变量</u>里。时间度量单位为Tick。</p><p>每过一个Tick（即一个计时单位，由操作系统定义），<u>时钟芯片都会向CPU发送一个时钟中断</u>。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><ul><li>紧急任务（1个tick，例如1ms）：<ul><li><u>运行进程</u>的优先级调整</li><li>终端<u>延时</u>处理</li></ul></li><li>非紧急任务（例如，1秒）：<ul><li>非运行态进程的优先级调整</li></ul></li></ul><h2 id="OS控制IO操作"><a href="#OS控制IO操作" class="headerlink" title="OS控制IO操作"></a>OS控制IO操作</h2><h3 id="硬件组成"><a href="#硬件组成" class="headerlink" title="硬件组成"></a>硬件组成</h3><ul><li><strong>机械部件</strong>（<strong>实施</strong>部件）：具体实现设备的操作</li><li><strong>电子部件</strong>（<strong>接口</strong>部件）：又叫设备控制器<ul><li>直接外接用于<u>控制和数据通信</u>的<u>电缆线</u></li><li>操作系统与<u>控制器</u>直接打交道，发送操作命令，或收发数据</li><li>控制器接收OS发来的操作指令，控制机械部件完成相应操作</li></ul></li></ul><h3 id="资源分配"><a href="#资源分配" class="headerlink" title="资源分配"></a>资源分配</h3><h4 id="I-O地址"><a href="#I-O地址" class="headerlink" title="I/O地址"></a>I/O地址</h4><ul><li><u>设备内部</u>的I/O编址：局限于单个设备</li><li><u>整个系统</u>I/O编址：需要把单个设备的I/O编址<strong>映射</strong>到系统全局编址<ul><li>与内存统一编址：同一般的内存访问操作</li><li>与内存分开编址：需要使用<u>专门的I/O指令</u>访问设备控制器的寄存器</li></ul></li></ul><blockquote><p>在设备接入之后，需要<strong>分配合适的I/O地址</strong>。设备内部的I/O地址要<strong>映射到所分配的I/O地址上</strong></p></blockquote><h4 id="I-O中断请求"><a href="#I-O中断请求" class="headerlink" title="I/O中断请求"></a>I/O中断请求</h4><ul><li>中断控制器支持的<strong>中断数量有限</strong>，每个进行了编号</li><li>设备接入系统后，需要<strong>分配中断号</strong>。一般情况下，多个设备<strong>不能共享</strong>同一中断号</li></ul><blockquote><p>没有合适的中断编号设备就<strong>不能正常工作</strong>。</p></blockquote><h4 id="DMA数据传输通道"><a href="#DMA数据传输通道" class="headerlink" title="DMA数据传输通道"></a>DMA数据传输通道</h4><div class="note primary modern"><p>关于IO通道</p></div><ul><li>I/O通道是一种硬件设施，带有<u>专用处理器</u>的，是有很强I/O处理功能的智能部件</li><li>可以<font color="blue">独立地完成系统处理器交付的I/O操作任务</font>，通道具有自己<strong>专门的指令集</strong>，即<strong>通道指令</strong></li><li>通道执行来自处理器的通道程序，完成后只需<u>向系统处理器发出中断</u>，请求结束</li></ul><div class="note primary modern"><p>IO通道分类</p></div><ul><li><strong>字节多路通道</strong><ul><li>用于连接<font color="blue">大量</font><font color="red">低、中速</font>的I/O设备，每次传输一个字节</li><li>以<strong>字节为单位</strong>交叉地工作，<font color="red">当为一台设备传送一个字节后，立即转去为另一台设备传送一个字节</font></li></ul></li><li><strong>选择通道</strong><ul><li>用于支持<font color="red">高速设备</font>（如磁盘），每次只与<font color="blue">一个设备</font>进行数据传输</li><li>数据传输是<strong>以块为单位</strong>，每次可以传输一批数据</li><li><font color="red">每当一个输入输出操作请求完成后，再选择与通道相连接的另一设备</font></li></ul></li><li><strong>成组多路通道</strong><ul><li>以<strong>分时方式</strong>同时执行几道通道程序，分别实现与<font color="blue">几个高速设备</font>的数据传输</li><li>实质是<font color="red">对通道程序采用多道程序设计技术的硬件实现</font> 。 </li></ul></li></ul><div class="note success modern"><p>DMA传输通道</p></div><ul><li><strong>内存和I/O设备之间</strong>的自动化数据通路，在主存和I/O设备之间成块传送数据过程中，<font color="red">不需要CPU干预</font>，CPU资源的利用率再次得到提高</li><li>DMA不仅设有中断机构，而且，还增加了DMA<strong>传输控制机构</strong>（类似于CPU)</li></ul><h4 id="I-O缓冲区"><a href="#I-O缓冲区" class="headerlink" title="I/O缓冲区"></a>I/O缓冲区</h4><ul><li><strong>需求</strong><ul><li>提高CPU和外设的<u>并行度</u></li><li>缓解<u>外设速度慢</u>的瓶颈</li></ul></li><li>分类<ul><li>硬件缓冲：有些设备中会包含专门的硬件寄存器等用于缓冲。</li><li>软件缓冲：直接在主存中<ul><li>单缓冲：一个缓冲，外设和CPU<u>互斥进行操作</u></li><li>双缓冲：设置两个缓冲区，交替使用</li><li>循环缓冲：类似于<u>循环队列</u>，依次使用</li><li><font color="red">缓冲池</font>：系统维护一组大小相同的缓冲区，进程和设备<strong>按需要申请</strong>，使用完后重新归入缓冲池中</li></ul></li></ul></li></ul><h3 id="资源控制"><a href="#资源控制" class="headerlink" title="资源控制"></a>资源控制</h3><p>使用<strong>设备控制表（DCT）</strong>控制设备。</p><h4 id="设备控制表（DCT）"><a href="#设备控制表（DCT）" class="headerlink" title="设备控制表（DCT）"></a>设备控制表（DCT）</h4><ul><li><p>作用：将抽象的<strong>I/O操作</strong>映射到实际的设备</p></li><li><p>记录内容：</p><ul><li>抽象设备描述</li><li>实际<u>设备地址</u></li><li>驱动程序参数等</li></ul></li><li><details>]    <summary>示例</summary>    <img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406050040213.png" alt="image-20240605004011179" style="zoom:80%;" /></details></li></ul><h4 id="设备开关表"><a href="#设备开关表" class="headerlink" title="设备开关表"></a>设备开关表</h4><ul><li>内容<ul><li>·设备号（对应于DCT中的设备号）</li><li><font color="red">打开设备的程序入口地址</font></li><li><font color="red">关闭设备的程序入口地址</font></li></ul></li></ul><p><img src="C:/Users/zhonghy/AppData/Roaming/Typora/typora-user-images/image-20240605100921648.png" alt="image-20240605100921648" style="zoom: 28%;" /></p><h2 id="Unix设备的管理分配"><a href="#Unix设备的管理分配" class="headerlink" title="Unix设备的管理分配"></a>Unix设备的管理分配</h2><h3 id="管理层次"><a href="#管理层次" class="headerlink" title="管理层次"></a>管理层次</h3><p>设备文件-&gt;设备开关表-&gt;驱动程序-&gt;I/O指令（控制寄存器）-&gt;硬件</p><h3 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h3><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><ul><li>为进程或作业分配所需的设备</li><li><font color="red">充分发挥设备的使用效率，尽可能避免**死锁**</font></li></ul><h4 id="分配方式"><a href="#分配方式" class="headerlink" title="分配方式"></a>分配方式</h4><ul><li>静态分配：<ul><li>作业开始运行时，一次性分配给所有可能使用到的设备</li><li>设备利用率低</li><li>简单，<u>不会出现死锁</u></li></ul></li><li>动态分配<ul><li>进程使用设备时再进行相应分配</li><li>设备利用高，<u>可能会出现死锁</u></li></ul></li></ul><h4 id="设备请求管理"><a href="#设备请求管理" class="headerlink" title="设备请求管理"></a>设备请求管理</h4><ul><li>要使用设备时<font color="red">必须</font>提供进行<u>I/O操作的有关信息</u>，指出执行I/O的逻辑<u>设备名</u>（如设备号）、<u>操作类型</u>、传送数据的<u>数目</u>、<u>信息源或目的地址</u>等。</li><li>存放进行I/O操作的信息的结构称为<font color="blue"> <strong>I/O请求块</strong> </font><ul><li>在UNIX系统中，系统的I/O请求块的内容是<font color="red">包含在缓冲区控制块buf</font>中</li></ul></li></ul><blockquote><p>在请求I/O时，首先<strong>请求分配缓冲区</strong>，然后把与操作有关的信息写到buf中，并把这个<strong>buf挂到请求设备的I/O请求队列</strong>中去</p></blockquote><ul><li><h4 id="分配原则"><a href="#分配原则" class="headerlink" title="分配原则"></a>分配原则</h4></li><li><p>独占设备：同时只能分配给<strong>一个请求进程</strong>。</p></li><li>共享设备：同时可以将一个设备分配给<strong>多个请求进程</strong>。</li><li>虚拟设备：用一个逻辑设备来<u>同时模拟</u><strong>多个独占</strong>设备，达到设备共享的目的，<u>提高设备利用率</u>。</li></ul><h4 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h4><h5 id="先请求先服务"><a href="#先请求先服务" class="headerlink" title="先请求先服务"></a>先请求先服务</h5><ul><li>系统按先后次序组成I/O请求队列，每个设备一个队列</li><li>当新的I/O请求块生成后，把该块挂在相应设备的I/O请求队列的<u>队尾</u></li><li><strong>设备空闲时</strong>，从该设备的I/O请求队列的队首取出一个请求块，并按这个请求块的要求进行I/O操作</li></ul><h5 id="按进程优先权确定服务次序"><a href="#按进程优先权确定服务次序" class="headerlink" title="按进程优先权确定服务次序"></a>按进程优先权确定服务次序</h5><ul><li>系统按请求进程的优先级由高到低次序组成I/O请求队列，每个设备一个队列。（多队列）</li><li>当新的I/O请求块生成后，根据请求优先级把该块挂在相应设备的I/O请求队列中的<u>合适位置</u>。</li><li>设备空闲时，从该设备的I/O请求队列的队首取出一个请求块，并按这个请求块的要求进行I/O操作</li></ul><h3 id="上层统一接口"><a href="#上层统一接口" class="headerlink" title="上层统一接口"></a>上层统一接口</h3><blockquote><ul><li>操作系统的设备管理需要<strong>隐藏</strong>设备的操作细节</li><li>解决问题<ul><li>如何用统一的方式来<strong>标示</strong>设备</li><li>如何用统一的方法来表示设备的<strong>不同操作</strong></li></ul></li></ul></blockquote><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ul><li>操作系统对上提供若干<font color="red">高级I/O系统调用</font>(getc, putc, read , write ,seek, open, close等)<ul><li>这些调用接口同<u>普通文件的调用接口</u></li><li>I/O系统调用对应抽象的I/O操作，包含对I/O设备的控制：<font color="red">请求、响应、处理控制、缓冲等</font></li><li>对这些抽象I/O操作请求，不同的设备具有不同的理解，对应<u>不同的设备动作</u></li></ul></li><li><strong>通过<font color="red">抽象的I/O操作</font>把应用程序与复杂的I/O设备控制隔离开来。</strong></li></ul><h3 id="设备的命名"><a href="#设备的命名" class="headerlink" title="设备的命名"></a>设备的命名</h3><div class="note success modern"><p>以文件名的形式来表示,这些文件叫设备文件</p></div><p>把设备文件和对应的设备（或<u>设备驱动程序</u>）联系起来的是设备文件的两个属性:</p><ul><li>主设备号：<strong>通过主设备号就可以找到相应的设备驱动程序</strong>。同种类型的设备如果驱动相同，<strong>主设备号可以相同</strong>。</li><li>次设备号：它作为传给驱动程序的<u>参数</u>指定<strong>具体的物理设备</strong>。</li></ul><h3 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h3><ul><li>设置了<u>多种队列</u>对所有缓冲区进行管理</li><li>因为buf记录了与缓冲区有关的各种管理信息，所以缓冲区管理队列<font color="red">实际上是缓存控制块buf队列</font>。</li></ul><h4 id="缓冲控制块buf"><a href="#缓冲控制块buf" class="headerlink" title="缓冲控制块buf"></a>缓冲控制块buf</h4><p>存储缓冲区信息、IO请求、执行结果</p><h4 id="buf队列"><a href="#buf队列" class="headerlink" title="buf队列"></a>buf队列</h4><ul><li>自由（空闲）buf 队列：FIFO</li><li>设备缓冲区队列：双向队列；被分配用于读、写某个设备的<strong>字符块</strong></li><li>空设备队列（NODEV队列）：特殊设备/无对应的实际设备（只有对应的<font color="red">特殊内容</font>）<ul><li>为程序传递参数</li><li>存放文件系统的<strong>资源管理块</strong></li></ul></li></ul><blockquote><p>系统初始化时会把所有的空间缓冲区buf同时放在<strong>自由buf和NODEV</strong>上</p></blockquote><ul><li>设备I/O请求队列：每个<strong>块设备</strong>有一个I/O请求队列（iobuf，<strong>单向连接</strong>）</li></ul><h4 id="缓冲区之间关系"><a href="#缓冲区之间关系" class="headerlink" title="==缓冲区之间关系=="></a>==缓冲区之间关系==</h4><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/study/NIS2336/image-20240605102419557.png" alt="image-20240605102419557" style="zoom:67%;" /></p><h4 id="管理算法"><a href="#管理算法" class="headerlink" title="管理算法"></a>管理算法</h4><div class="note primary modern"><p>采用LRU算法</p></div><ul><li>一个缓存刚分配用于读写某一块设备，buf的b_flags含有<strong>B_BUSY标志</strong>。它一定位于相应<strong>设备buf队列，不在自由队列</strong>。</li><li>一旦读写完成，就释放缓存，<strong>清B_BUSY标志</strong>。送入自由队列尾，但<strong>仍留在原设备队列</strong>。</li></ul><p><strong><font color = "red">优点</font></strong>：</p><ul><li><strong>避免了重复I/O</strong>：只要还要重复使用原设备队列中该缓存内容，就只要简单地将其从自由队列抽出即可</li><li><strong>实现延迟写</strong>:实现了异步延迟写机制</li></ul><h3 id="字符设备管理"><a href="#字符设备管理" class="headerlink" title="字符设备管理"></a>字符设备管理</h3><ul><li>需要两个寄存器<ul><li><strong>控制状态</strong>寄存器</li><li><strong>数据缓冲</strong>寄存器</li></ul></li><li>作为一个特殊文件来处理</li><li>数据流与控制流<ul><li><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/study/NIS2336/image-20240605103747894.png" alt="image-20240605103747894" style="zoom:33%;" /></li></ul></li><li>缓冲区非常小；三种队列：原始（读入）、规范（转换）、输出（写出）</li></ul><h2 id="Linux设备管理"><a href="#Linux设备管理" class="headerlink" title="Linux设备管理"></a>Linux设备管理</h2><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/study/NIS2336/image-20240605104202968.png" alt="image-20240605104202968" style="zoom:50%;" /></p><h3 id="接口管理"><a href="#接口管理" class="headerlink" title="接口管理"></a>接口管理</h3><ul><li>每台设备用一个特殊设备文件来表示。/dev/hda表示第一个磁盘，/dev/hda1表示第一个磁盘的第一个分区。（device）</li><li>通过<strong>访问文件的接口</strong>就能实现对设备的访问。</li></ul><h3 id="驱动程序"><a href="#驱动程序" class="headerlink" title="驱动程序"></a>驱动程序</h3><ul><li>运行在<strong>核心态</strong></li><li>对应用层提供标准接口</li><li>灵活性<ul><li><strong>可配置，可以通过配置选择特定的驱动程序编译到内核中。</strong></li><li>也可以编译成<strong>模块，</strong>实现动态加载</li></ul></li></ul><h3 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h3><ul><li><font color =red>字符设备矢量表</font><ul><li>每一项对应一个设备。每一项的信息包含<strong>设备控制块指针</strong>，以及各种抽象操作的<strong>实现函数</strong></li></ul></li><li><font color =red>虚拟文件系统</font><ul><li>能够实现<strong>文件操作到实现函数的映射</strong></li></ul></li></ul><h3 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h3><ul><li>与字符设备的相同点<ul><li>对上提供文件操作类似的接口</li><li>存在与字符设备矢量表功能类似的<strong>块设备矢量表</strong></li></ul></li><li>与字符设备的差别<ul><li>与<font color =red>高速缓冲区间</font>存在接口</li><li>需要管理相应的<font color =red>队列。</font></li></ul></li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul><li>网络设备是<u>发送和接收数据包</u>的实体。</li><li>通常对应于<strong>网卡</strong></li></ul><h1 id="遗留作业"><a href="#遗留作业" class="headerlink" title="遗留作业"></a>遗留作业</h1><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><div class="note primary modern"><p>Spooling和内存缓冲技术的区别</p></div><p>Spooling（Simultaneous Peripheral Operations On-Line）和内存缓冲技术是用来提高计算机系统性能的两种不同技术：</p><ol><li><p><strong>Spooling</strong>：</p><ul><li><strong>定义</strong>：Spooling 是一种技术，它允许计算机在执行多个任务时，将这些任务的输入和输出数据暂时存储在磁盘或其他介质上，而不是直接在主内存中处理。</li><li><strong>作用</strong>：通过将输入/输出数据缓冲到磁盘上的临时存储区域，系统可以更高效地管理多个任务的输入输出，避免了需要等待长时间的磁盘访问操作。</li></ul></li><li><p><strong>内存缓冲技术</strong>：</p><ul><li><strong>定义</strong>：内存缓冲技术是一种通过使用计算机内存中的缓冲区来存储数据，从而改善数据传输和处理效率的技术。</li><li><strong>作用</strong>：内存缓冲可以在数据传输和处理过程中，暂时存储数据，减少因为数据传输速度不匹配而导致的等待时间，提高系统性能和响应速度。</li></ul></li></ol><p><strong>区别</strong>：</p><ul><li><strong>存储位置</strong>：Spooling 将数据存储在磁盘或其他非易失性介质上，而内存缓冲技术将数据存储在计算机内存中。</li><li><strong>使用场景</strong>：Spooling 主要用于管理和调度多个任务的输入输出，而内存缓冲技术更多用于优化数据传输和处理效率。</li><li><strong>实现方式</strong>：Spooling 通常需要特定的操作系统支持和软件实现，而内存缓冲可以通过应用程序或操作系统本身实现。</li></ul><p>总之，这两种技术都旨在提高计算机系统的效率和响应速度，但它们的应用场景和实现方式有所不同。</p><div class="note primary modern"><p>Spooling和内存缓冲技术的区别</p></div><p>Spooling（假脱机）和真正的脱机技术是计算机领域中两种不同的数据处理和管理方式：</p><ol><li><p><strong>Spooling（假脱机）</strong>：</p><ul><li><strong>定义</strong>：Spooling 是一种技术，它允许计算机系统将任务的输入和输出数据暂时存储在磁盘或其他介质上，而不是直接在主内存中处理。这种方式使得系统可以并行处理多个任务的输入输出，而不会因为等待磁盘访问而导致性能下降。</li><li><strong>特点</strong>：Spooling 本质上是一种虚拟的脱机操作，因为它并不真正将数据传输到物理脱机设备上，而是将数据缓存到临时存储区域（如磁盘）以便后续处理。</li></ul></li><li><p><strong>真正的脱机技术</strong>：</p><ul><li><strong>定义</strong>：真正的脱机技术涉及将数据完全从计算机系统中取出，并通过物理介质（如磁带或光盘）存储到脱机设备中，然后在需要时再将数据取回计算机系统进行处理。</li><li><strong>特点</strong>：脱机技术通常用于大规模数据存储和备份，它可以有效地释放计算机系统的资源，因为数据不需要在系统活动时持续占用内存或处理器。</li></ul></li></ol><p><strong>区别</strong>：</p><ul><li><strong>操作对象</strong>：Spooling 是针对任务的输入输出数据进行缓冲和管理，而真正的脱机技术则是针对大量数据的物理存储和处理。</li><li><strong>存储介质</strong>：Spooling 使用磁盘等非易失性存储介质作为缓冲区，而脱机技术使用磁带、光盘等物理介质作为数据的永久存储。</li><li><strong>应用场景</strong>：Spooling 主要用于多任务并发处理的输入输出优化，而脱机技术则更多用于数据备份、长期存储和数据迁移等大规模数据处理场景。</li></ul><p>总结来说，Spooling 是一种虚拟的脱机操作技术，通过缓冲数据到磁盘上来提高系统效率；而真正的脱机技术则是实际将数据存储到物理脱机设备上，用于长期存储和备份。</p><div class="note primary modern"><p>Unix系统的基本结构分为哪几层</p></div><details>    <summary>Unix系统的基本结构</summary>    <p><strong>硬件层：</strong> 包括计算机的物理硬件，如CPU、内存、磁盘驱动器、网络接口等。它是Unix系统赖以运行的基础。</p>    <p><strong>内核层：</strong> 内核是Unix系统的核心部分，负责管理硬件资源，并为上层软件提供服务。内核主要功能包括进程管理、内存管理、文件系统管理、设备驱动、系统调用接口等。</p>    <p><strong>系统调用接口层：</strong> 系统调用接口（System Call Interface, SCI）是用户进程和内核之间的桥梁。它提供一组标准的接口，允许用户进程请求内核服务，如文件操作、进程控制、内存分配等。</p>    <p><strong>库函数层：</strong> 库函数层由标准C库（libc）等组成，提供常用的编程接口和工具函数。库函数通常封装系统调用，简化应用程序开发。</p>    <p><strong>用户命令和应用程序层：</strong> 包括各种用户命令、系统管理工具和应用程序。这一层直接与用户交互，为用户提供功能强大的操作和管理工具。常见的用户命令有<code>ls</code>、<code>cp</code>、<code>mv</code>等。</p>    <p><strong>用户层：</strong> 用户层是Unix系统的最外层，包括最终用户和系统管理员，他们通过命令行界面（CLI）或图形用户界面（GUI）与系统交互。</p></details>    <h2 id="磁盘调度-1"><a href="#磁盘调度-1" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><ul><li><strong>磁盘调度</strong></li></ul><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406032358632.png" alt="image-20240603235836608" style="zoom:80%;" /></p><p>1. </p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
          <category> class </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> 2023-2024Spring </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/05/26/hello-world/"/>
      <url>/2024/05/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
