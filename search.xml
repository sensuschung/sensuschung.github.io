<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>monad概览</title>
      <link href="/2024/06/03/monad%E6%A6%82%E8%A7%88/"/>
      <url>/2024/06/03/monad%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li><code>m</code>类型构造子</li><li><code>return :: a -&gt; M a</code>：（也叫做<code>unit</code>），接受一个类型<code>a</code>的值，把它们包装成使用这个类型构造子建造的类型<code>m a</code>的“单子值”</li><li><code>bind :: (M a) -&gt; (a -&gt; M b) -&gt; (M b)</code> ：也可写作 <code>&gt;&gt;=</code>，接受一个在类型<code>a</code>上的函数<code>f</code>，并应用<code>f</code>于去包装的值<code>a</code>，转变单体值<code>m a</code>。</li></ul><p>通过以上元素，复合出一个函数调用的序列，在一个表达式中通过一些<strong>bind算子</strong>把它们链接起来。</p><p>每个函数调用<u>转变</u>它的输入普通类型值，而bind算子<u>处理返回的单子值</u>，它被填入到序列中下一个步骤。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><div class="note primary modern"><p>案例：maybe</p></div><ul><li>需要显示定义函数的返回状态：<code>Just ⌑result⌑</code>, or <code>Nothing</code></li></ul><p>案例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(x: Decimal, y: Decimal) <span class="punctuation">-&gt;</span> Maybe&lt;Decimal&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> y == <span class="number">0</span> &#123; <span class="keyword">return</span> Nothing &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="title function_ invoke__">Just</span>(x / y) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// divide(1.0, 4.0) -&gt; returns Just(0.25)</span></span><br><span class="line"><span class="comment">// divide(3.0, 0.0) -&gt; returns Nothing</span></span><br></pre></td></tr></table></figure><ul><li>检查<code>Maybe</code>算子返回的值(上)或使用类型匹配（下）</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">m_x</span> = <span class="title function_ invoke__">divide</span>(<span class="number">3.14</span>, <span class="number">0.0</span>); <span class="comment">// see divide function above</span></span><br><span class="line"><span class="comment">// The if statement extracts x from m_x if m_x is the Just variant of Maybe</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Just</span>(x) = m_x &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;answer: &quot;</span>, x)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;division failed, divide by zero error...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">divide</span>(<span class="number">3.0</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="keyword">match</span> result &#123;</span><br><span class="line">    <span class="title function_ invoke__">Just</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Answer: &quot;</span>, x),</span><br><span class="line">    Nothing =&gt; <span class="built_in">println!</span>(<span class="string">&quot;division failed; we&#x27;ll get &#x27;em next time.&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多输入monad，单输出monad</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">chainable_division</span>(maybe_x: Maybe&lt;Decimal&gt;, maybe_y: Maybe&lt;Decimal&gt;) <span class="punctuation">-&gt;</span> Maybe&lt;Decimal&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> (maybe_x, maybe_y) &#123;</span><br><span class="line">        (<span class="title function_ invoke__">Just</span>(x), <span class="title function_ invoke__">Just</span>(y)) =&gt; &#123; <span class="comment">// If both inputs are Just, check for division by zero and divide accordingly</span></span><br><span class="line">            <span class="keyword">if</span> y == <span class="number">0</span> &#123; <span class="keyword">return</span> Nothing &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="title function_ invoke__">Just</span>(x / y) &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> Nothing <span class="comment">// Otherwise return Nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">chainable_division</span>(<span class="title function_ invoke__">chainable_division</span>(<span class="title function_ invoke__">Just</span>(<span class="number">2.0</span>), <span class="title function_ invoke__">Just</span>(<span class="number">0.0</span>)), <span class="title function_ invoke__">Just</span>(<span class="number">1.0</span>)); <span class="comment">// inside chainable_division fails, outside chainable_division returns Nothing</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>&gt;&gt;=</code>来传递多次匿名函数；多参数处理</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">halve</span> :: <span class="type">Int</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">halve</span> x</span><br><span class="line">  | even x = <span class="type">Just</span> (x `div` <span class="number">2</span>)</span><br><span class="line">  | odd x  = <span class="type">Nothing</span></span><br><span class="line"> <span class="comment">-- This code halves x twice. it evaluates to Nothing if x is not a multiple of 4</span></span><br><span class="line"><span class="title">halve</span> x &gt;&gt;= halve</span><br></pre></td></tr></table></figure><blockquote><p>x >>= y即把x传递给函数y获得返回值</p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">chainable_division</span>(mx,my) =   mx &gt;&gt;=  ( λx -&gt;   my &gt;&gt;= (λy -&gt; <span class="type">Just</span> (x / y))   )</span><br></pre></td></tr></table></figure><blockquote><p>在此处的$\lambda$表示匿名函数</p></blockquote><p>在上面的案例中，有以下几种类型：</p><ul><li><em>Monadic Type</em>：<code>Maybe</code></li><li><em>Unit operation</em>（类型转换）：<code>Just(x)</code></li><li><em>Bind operation</em>（组合子）： <code>&gt;&gt;=</code> or <code>.flatMap()</code></li></ul><h1 id="标准定义"><a href="#标准定义" class="headerlink" title="标准定义"></a>标准定义</h1><h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><ul><li><p><strong>A <a href="https://en.wikipedia.org/wiki/Type_constructor">type constructor</a></strong> <em>M</em> that builds up a <strong>monadic type</strong> <code>M T</code></p></li><li><p><strong>type converter</strong>常被叫做 <strong>unit</strong> or <strong>return</strong>，用于将一个对象<code>x</code>嵌入到单子中，<code>unit(x) :: T -&gt; M T</code></p></li><li><p><strong>combinator</strong> 典型的叫做<strong>bind</strong>，并表示为中缀算子<code>&gt;&gt;=</code>，去<u>包装</u>一个单体变量，接着把它插入到一个单体函数/表达式之中，结果为一个新的单体值：</p></li><li><code>(&gt;&gt;=) : (M T, T → M U) → M U</code>so if <code>mx : M T</code> and <code>f : T → M U</code>, then <code>(mx &gt;&gt;= f) : M U</code></li></ul><h2 id="遵循定律"><a href="#遵循定律" class="headerlink" title="遵循定律"></a>遵循定律</h2><ul><li>unit是bind的左单比特 <code>unit(x) &gt;&gt;= f</code> <strong>↔</strong> <code>f(x)</code></li><li>unit是bind的右单比特 <code>ma &gt;&gt;= unit</code> <strong>↔</strong> <code>ma</code></li></ul><blockquote><p>此处左单比特、右单比特即单位元，identity</p></blockquote><ul><li>bind符合结合律 <code>ma &gt;&gt;= λx → (f(x) &gt;&gt;= g)</code> <strong>↔</strong> <code>(ma &gt;&gt;= f) &gt;&gt;= g</code></li></ul><blockquote><p>单子构成在函子（functor）范畴上的<a href="https://zh.wikipedia.org/wiki/%E5%B9%BA%E5%8D%8A%E7%BE%A4">幺半群</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
          <category> functional programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> function programming </tag>
            
            <tag> monad </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIS2336</title>
      <link href="/2024/06/02/NIS2336/"/>
      <url>/2024/06/02/NIS2336/</url>
      
        <content type="html"><![CDATA[<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>[ ] 翻译程序</li><li>[ ] 编译程序</li><li>[ ] 编译的两大/三大阶段及区别（编译阶段生成的目标程序）</li><li><p>[ ] 解释程序和编译程序的主要区别</p></li><li><p>[ ] 编译的六个阶段、前端和后端</p></li><li>[ ] 词法分析：源程序、字符串、扫描分解、单词/单词符号/符号</li><li>[ ] 语法分析：单词符号串、语法规则、识别语法单位、检查</li><li>[ ] 语义分析、中间代码生成：语法单位、静态语义省查、分析含义、另一种语言描述（什么语言？）</li><li>[ ] 代码优化：对（）进行（）改造或变换，高效，主要包括（）和（）</li><li>[ ] 目标代码生成：将中间代码变换成（）或（）或（）</li><li>[ ] 在<strong>每个</strong>过程中，涉及表格管理和错误处理：表格的构造、查找、修改、存取</li></ul><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/study/NIS2334/image-20240530102430879.png" alt="编译流程" style="zoom: 50%;" /></p><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><ul><li>[ ] 上面的图中的流程是逻辑关系吗？是执行时间上的先后关系吗？可按照不同的执行流程来组织吗？<ul><li>[ ] 相关：一遍扫描?多遍扫描？开始和结束？优缺点？</li></ul></li><li>[ ] 编译程序：复杂系统程序</li></ul><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><h2 id="字母表和符号串"><a href="#字母表和符号串" class="headerlink" title="字母表和符号串"></a>字母表和符号串</h2><ul><li>[ ] 字母表：含义、个数、类型</li><li>[ ] 符号/字符</li><li>[ ] 符号串：有穷、特定、空</li><li>[ ] 运算：符号串（连接、幂运算）集合（乘积、闭包、正闭包）</li></ul><h2 id="文法和语言"><a href="#文法和语言" class="headerlink" title="文法和语言"></a>文法和语言</h2><ul><li>[ ] 形式语言、描述方法（枚举、文法）</li><li>[ ] 规则：终结符与非终结符</li><li>[ ] 文法：四元组、字汇表、关键、候选式与识别符号</li><li>[ ] </li></ul><h2 id="判断-1"><a href="#判断-1" class="headerlink" title="判断"></a>判断</h2><ul><li>[ ] 形式语言考虑语义。</li></ul><h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><h3 id="文法的设计"><a href="#文法的设计" class="headerlink" title="文法的设计"></a>文法的设计</h3><ol><li><p>根据字母表设计文法</p><blockquote><p>相同的幂必须合并在一起</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
          <category> class </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> 2023-2024Spring </tag>
            
            <tag> compiling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIS2334</title>
      <link href="/2024/06/02/NIS2334/"/>
      <url>/2024/06/02/NIS2334/</url>
      
        <content type="html"><![CDATA[<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="磁盘结构和调度"><a href="#磁盘结构和调度" class="headerlink" title="磁盘结构和调度"></a>磁盘结构和调度</h3><ul><li><p>[ ] 磁盘结构</p><ul><li>[ ] 控制器通过移动臂移动磁头读写磁道上的数据。<strong>每面</strong>都有独立的磁头</li><li>[ ] 柱面: 所有盘片上的<strong>相同磁道</strong>组成柱面</li></ul></li><li><p>[ ] <font color="#CC0000">磁盘时延</font></p><details>    <summary>具体计算</summary>    <img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/study/NIS2336/image-20240531151357537.png" alt="1"></details></li><li><p>[ ] 磁道优化</p><details>    <summary>优化方案</summary>    <ul>        <li>所有磁道上的BPI 相同(“固定位密度”)</li>        <li>磁盘容量更大</li>        <li>越靠外圈的磁道包含的扇区越多</li>        <li>磁盘转速固定，外磁道的速度比内磁道</li>    </ul></details></li><li><p>[ ] 硬盘的使用</p><ul><li>[ ] 硬盘必须分区</li><li>[ ] 分区需用<u>某种文件系统</u>进行格式化</li><li>[ ] 在某些情况下，可以用快速格式化取代完全格式化</li><li>[ ] 为什么需要多分区</li></ul></li><li><p>[ ] 磁盘分布</p><ul><li>[ ] MBR（位置）、4个主分区、多个逻辑分区</li></ul></li><li><p>[ ] 减少时延的方法：<br>缓存/RAM/RAID/调度算法(读写头调度-&gt;调动磁头、元信息布置-&gt;怎么储存布置文件块)</p><ul><li><p>[ ] <details></p><pre><code>&lt;summary&gt;关于高速缓存&lt;/summary&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sensuschung/wordpress_image/master/study/NIS2336/20240531153644.png&quot; alt=&quot;none&quot;&gt;</code></pre><p>&lt;/details&gt;</p></li><li><p>[ ] <font color="#CC0000">替换策略</font>：</p><ul><li>[ ] LRU</li><li>[ ] LFU</li><li>[ ] 基于频率的替换算法</li></ul></li><li><p>[ ] </p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
          <category> class </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> 2023-2024Spring </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/05/26/hello-world/"/>
      <url>/2024/05/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
