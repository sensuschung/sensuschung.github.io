<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>monad概览</title>
      <link href="/2024/06/03/monad%E6%A6%82%E8%A7%88/"/>
      <url>/2024/06/03/monad%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li><code>m</code>类型构造子</li><li><code>return :: a -&gt; M a</code>：（也叫做<code>unit</code>），接受一个类型<code>a</code>的值，把它们包装成使用这个类型构造子建造的类型<code>m a</code>的“单子值”</li><li><code>bind :: (M a) -&gt; (a -&gt; M b) -&gt; (M b)</code> ：也可写作 <code>&gt;&gt;=</code>，接受一个在类型<code>a</code>上的函数<code>f</code>，并应用<code>f</code>于去包装的值<code>a</code>，转变单体值<code>m a</code>。</li></ul><p>通过以上元素，复合出一个函数调用的序列，在一个表达式中通过一些<strong>bind算子</strong>把它们链接起来。</p><p>每个函数调用<u>转变</u>它的输入普通类型值，而bind算子<u>处理返回的单子值</u>，它被填入到序列中下一个步骤。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><div class="note primary modern"><p>案例：maybe</p></div><ul><li>需要显示定义函数的返回状态：<code>Just ⌑result⌑</code>, or <code>Nothing</code></li></ul><p>案例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(x: Decimal, y: Decimal) <span class="punctuation">-&gt;</span> Maybe&lt;Decimal&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> y == <span class="number">0</span> &#123; <span class="keyword">return</span> Nothing &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="title function_ invoke__">Just</span>(x / y) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// divide(1.0, 4.0) -&gt; returns Just(0.25)</span></span><br><span class="line"><span class="comment">// divide(3.0, 0.0) -&gt; returns Nothing</span></span><br></pre></td></tr></table></figure><ul><li>检查<code>Maybe</code>算子返回的值(上)或使用类型匹配（下）</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">m_x</span> = <span class="title function_ invoke__">divide</span>(<span class="number">3.14</span>, <span class="number">0.0</span>); <span class="comment">// see divide function above</span></span><br><span class="line"><span class="comment">// The if statement extracts x from m_x if m_x is the Just variant of Maybe</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Just</span>(x) = m_x &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;answer: &quot;</span>, x)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;division failed, divide by zero error...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">divide</span>(<span class="number">3.0</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="keyword">match</span> result &#123;</span><br><span class="line">    <span class="title function_ invoke__">Just</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Answer: &quot;</span>, x),</span><br><span class="line">    Nothing =&gt; <span class="built_in">println!</span>(<span class="string">&quot;division failed; we&#x27;ll get &#x27;em next time.&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多输入monad，单输出monad</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">chainable_division</span>(maybe_x: Maybe&lt;Decimal&gt;, maybe_y: Maybe&lt;Decimal&gt;) <span class="punctuation">-&gt;</span> Maybe&lt;Decimal&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> (maybe_x, maybe_y) &#123;</span><br><span class="line">        (<span class="title function_ invoke__">Just</span>(x), <span class="title function_ invoke__">Just</span>(y)) =&gt; &#123; <span class="comment">// If both inputs are Just, check for division by zero and divide accordingly</span></span><br><span class="line">            <span class="keyword">if</span> y == <span class="number">0</span> &#123; <span class="keyword">return</span> Nothing &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="title function_ invoke__">Just</span>(x / y) &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> Nothing <span class="comment">// Otherwise return Nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">chainable_division</span>(<span class="title function_ invoke__">chainable_division</span>(<span class="title function_ invoke__">Just</span>(<span class="number">2.0</span>), <span class="title function_ invoke__">Just</span>(<span class="number">0.0</span>)), <span class="title function_ invoke__">Just</span>(<span class="number">1.0</span>)); <span class="comment">// inside chainable_division fails, outside chainable_division returns Nothing</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>&gt;&gt;=</code>来传递多次匿名函数；多参数处理</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">halve</span> :: <span class="type">Int</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">halve</span> x</span><br><span class="line">  | even x = <span class="type">Just</span> (x `div` <span class="number">2</span>)</span><br><span class="line">  | odd x  = <span class="type">Nothing</span></span><br><span class="line"> <span class="comment">-- This code halves x twice. it evaluates to Nothing if x is not a multiple of 4</span></span><br><span class="line"><span class="title">halve</span> x &gt;&gt;= halve</span><br></pre></td></tr></table></figure><blockquote><p>x >>= y即把x传递给函数y获得返回值</p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">chainable_division</span>(mx,my) =   mx &gt;&gt;=  ( λx -&gt;   my &gt;&gt;= (λy -&gt; <span class="type">Just</span> (x / y))   )</span><br></pre></td></tr></table></figure><blockquote><p>在此处的$\lambda$表示匿名函数</p></blockquote><p>在上面的案例中，有以下几种类型：</p><ul><li><em>Monadic Type</em>：<code>Maybe</code></li><li><em>Unit operation</em>（类型转换）：<code>Just(x)</code></li><li><em>Bind operation</em>（组合子）： <code>&gt;&gt;=</code> or <code>.flatMap()</code></li></ul><h1 id="标准定义"><a href="#标准定义" class="headerlink" title="标准定义"></a>标准定义</h1><h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><ul><li><p><strong>A <a href="https://en.wikipedia.org/wiki/Type_constructor">type constructor</a></strong> <em>M</em> that builds up a <strong>monadic type</strong> <code>M T</code></p></li><li><p><strong>type converter</strong>常被叫做 <strong>unit</strong> or <strong>return</strong>，用于将一个对象<code>x</code>嵌入到单子中，<code>unit(x) :: T -&gt; M T</code></p></li><li><p><strong>combinator</strong> 典型的叫做<strong>bind</strong>，并表示为中缀算子<code>&gt;&gt;=</code>，去<u>包装</u>一个单体变量，接着把它插入到一个单体函数/表达式之中，结果为一个新的单体值：</p></li><li><code>(&gt;&gt;=) : (M T, T → M U) → M U</code>so if <code>mx : M T</code> and <code>f : T → M U</code>, then <code>(mx &gt;&gt;= f) : M U</code></li></ul><h2 id="遵循定律"><a href="#遵循定律" class="headerlink" title="遵循定律"></a>遵循定律</h2><ul><li>unit是bind的左单比特 <code>unit(x) &gt;&gt;= f</code> <strong>↔</strong> <code>f(x)</code></li><li>unit是bind的右单比特 <code>ma &gt;&gt;= unit</code> <strong>↔</strong> <code>ma</code></li></ul><blockquote><p>此处左单比特、右单比特即单位元，identity</p></blockquote><ul><li>bind符合结合律 <code>ma &gt;&gt;= λx → (f(x) &gt;&gt;= g)</code> <strong>↔</strong> <code>(ma &gt;&gt;= f) &gt;&gt;= g</code></li></ul><blockquote><p>单子构成在函子（functor）范畴上的<a href="https://zh.wikipedia.org/wiki/%E5%B9%BA%E5%8D%8A%E7%BE%A4">幺半群</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
          <category> functional programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> function programming </tag>
            
            <tag> monad </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIS2336</title>
      <link href="/2024/06/02/NIS2336/"/>
      <url>/2024/06/02/NIS2336/</url>
      
        <content type="html"><![CDATA[<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>[ ] 翻译程序</li><li>[ ] 编译程序</li><li>[ ] 编译的两大/三大阶段及区别（编译阶段生成的目标程序）</li><li><p>[ ] 解释程序和编译程序的主要区别</p></li><li><p>[ ] 编译的六个阶段、前端和后端</p></li><li>[ ] 词法分析：源程序、字符串、扫描分解、单词/单词符号/符号</li><li>[ ] 语法分析：单词符号串、语法规则、识别语法单位、检查</li><li>[ ] 语义分析、中间代码生成：语法单位、静态语义省查、分析含义、另一种语言描述（什么语言？）</li><li>[ ] 代码优化：对（）进行（）改造或变换，高效，主要包括（）和（）</li><li>[ ] 目标代码生成：将中间代码变换成（）或（）或（）</li><li>[ ] 在<strong>每个</strong>过程中，涉及表格管理和错误处理：表格的构造、查找、修改、存取</li></ul><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/study/NIS2334/image-20240530102430879.png" alt="编译流程" style="zoom: 50%;" /></p><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><ul><li>[ ] 上面的图中的流程是逻辑关系吗？是执行时间上的先后关系吗？可按照不同的执行流程来组织吗？<ul><li>[ ] 相关：一遍扫描?多遍扫描？开始和结束？优缺点？</li></ul></li><li>[ ] 编译程序：复杂系统程序</li></ul><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><h2 id="字母表和符号串"><a href="#字母表和符号串" class="headerlink" title="字母表和符号串"></a>字母表和符号串</h2><ul><li>[ ] 字母表：含义、个数、类型</li><li>[ ] 符号/字符</li><li>[ ] 符号串：有穷、特定、空</li><li>[ ] 运算：符号串（连接、幂运算）集合（乘积、闭包、正闭包）</li></ul><h2 id="文法和语言"><a href="#文法和语言" class="headerlink" title="文法和语言"></a>文法和语言</h2><ul><li>[ ] 形式语言、描述方法（枚举、文法）</li><li>[ ] 规则：终结符与非终结符</li><li>[ ] 文法：四元组、字汇表、关键、候选式与识别符号</li><li>[ ] </li></ul><h2 id="判断-1"><a href="#判断-1" class="headerlink" title="判断"></a>判断</h2><ul><li>[ ] 形式语言考虑语义。</li></ul><h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><h3 id="文法的设计"><a href="#文法的设计" class="headerlink" title="文法的设计"></a>文法的设计</h3><ol><li><p>根据字母表设计文法</p><blockquote><p>相同的幂必须合并在一起</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
          <category> class </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> 2023-2024Spring </tag>
            
            <tag> compiling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIS2334</title>
      <link href="/2024/06/02/NIS2334/"/>
      <url>/2024/06/02/NIS2334/</url>
      
        <content type="html"><![CDATA[<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="磁盘结构和调度"><a href="#磁盘结构和调度" class="headerlink" title="磁盘结构和调度"></a>磁盘结构和调度</h2><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><ul><li>控制器通过移动臂移动磁头读写磁道上的数据。<strong>每面</strong>都有独立的磁头</li><li>柱面: 所有盘片上的<strong>相同磁道</strong>组成柱面</li></ul><h3 id="磁盘时延"><a href="#磁盘时延" class="headerlink" title="磁盘时延"></a><font color="#CC0000">磁盘时延</font></h3><details>    <summary>具体计算</summary>    <img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/study/NIS2336/image-20240531151357537.png" alt="1"></details><ul><li><p>磁道优化</p><details>    <summary>优化方案</summary>    <ul>        <li>所有磁道上的BPI 相同(“固定位密度”)</li>        <li>磁盘容量更大</li>        <li>越靠外圈的磁道包含的扇区越多</li>        <li>磁盘转速固定，外磁道的速度比内磁道</li>    </ul></details></li></ul><h4 id="硬盘的使用"><a href="#硬盘的使用" class="headerlink" title="硬盘的使用"></a>硬盘的使用</h4><ul><li>硬盘必须分区</li><li>分区需用<u>某种文件系统</u>进行格式化</li><li>在某些情况下，可以用快速格式化取代完全格式化</li><li>为什么需要多分区</li><li><p>磁盘分布</p><ul><li>MBR（位置）、4个主分区、多个逻辑分区</li></ul></li></ul><h3 id="减少时延的方法："><a href="#减少时延的方法：" class="headerlink" title="减少时延的方法："></a>减少时延的方法：</h3><blockquote><p>缓存/</p><p>使用RAM磁盘/</p><p>RAID/</p><p>调度算法(读写头调度-&gt;调动磁头、元信息布置-&gt;怎么储存布置文件块)</p></blockquote><h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><ul><li><details>   <summary>关于高速缓存</summary>   <img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/study/NIS2336/20240531153644.png" alt="none"></details></li></ul><h4 id="替换策略："><a href="#替换策略：" class="headerlink" title="替换策略："></a><font color="#CC0000">替换策略</font>：</h4><ul><li>LRU</li><li>LFU</li><li>基于频率的替换算法<ul><li>优点：弱化集中访问对计数器的影响</li><li>具体实现：栈，计数器，新老两个区</li><li><img src="C:/Users/Windows11/AppData/Roaming/Typora/typora-user-images/image-20240603232956523.png" alt="image-20240603232956523" style="zoom:50%;" /></li><li>存在问题：新加入的块，如果很<u>快进入老区</u>，则没有竞争力，将很快被淘汰。</li></ul></li></ul><h4 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a><font color="#CC0000">磁盘调度</font></h4><ul><li>作用<ul><li>提高有效的<strong>数据吞吐率</strong></li><li>减少请求的<strong>平均等待时间</strong></li></ul></li><li>总结图<ul><li><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406032354849.png" alt="image-20240603235447821" style="zoom:80%;" /></li></ul></li><li><font color="red"> 常用调度策略</font></li><li><strong>FCFS</strong><ul><li>按请求的<u>时间顺序</u>，依次进行服务</li><li><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406032338650.png" alt="image-20240603233837629" style="zoom:80%;" /></li><li>优点：<ul><li>实现简单</li><li>有大量进程竞争时，在性能上接近于<strong>随机调度</strong></li></ul></li><li>缺点<ul><li><strong>寻道时间长</strong>，磁头<u>移动幅度大</u></li></ul></li><li>适合<strong>较轻负载</strong>的系统</li></ul></li><li><strong>SSTF最短寻道时间优先</strong><ul><li>优先响应寻道时间最短的请求</li><li><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406032343619.png" alt="image-20240603234311601" style="zoom:80%;" /></li><li>优点<ul><li><strong>寻道时间</strong>较短，<strong>服务效率</strong>较高，服务<strong>平均等待时间</strong>较短</li><li>提供比<u>FIFO</u>更高的效率</li></ul></li><li>缺点<ul><li><strong>公平性</strong>差，可能会出现服务请求长期得不到服务，甚至饿死</li><li><u>寻道时间</u>并不能真正实现最优。</li></ul></li><li>适合<strong>中度负载</strong>的系统</li></ul></li><li><strong>SCAN（电梯）算法</strong><ul><li>磁头<u>从一端出发向另一端移动</u>，移动过程中，发现有请求<u>对应磁头下的磁道</u>，就对该请求提供服务。到另一端后，开始反向移动，遇到请求进行服务</li><li><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406032347031.png" alt="image-20240603234757011" style="zoom:80%;" /></li><li>缺点：<ul><li>每个请求的等待时间不均匀，且<strong>平均等待时间</strong>长</li></ul></li><li>优化<ul><li><font color="blue">磁头并不是每次扫描都移动到最远的磁道上</font>，一旦在当前方向上前面没有请求，就开始反向移动。</li></ul></li><li>比较适合磁盘<strong>负载较重</strong>的系统</li></ul></li><li><strong>C-SCAN</strong><ul><li>类似电梯算法。但需要<strong>从零道开始</strong>。</li><li>磁头移动方向单一（从内到外）</li></ul></li><li>PRI进程优先级</li><li>LIFO（后进先出）<ul><li>局部性最好，资源利用率最高（等待时间少、缓存命中高）</li></ul></li><li>N-step-scan<ul><li>把请求分为<u>长度为N</u>的多个队列；一次处理一个队列；新到的请求加到其他队列中。</li><li>特性：<u>N较大时，等价于SCAN；N=1时，等价于FIFO</u></li></ul></li><li>FSCAN</li></ul><div class="note primary modern"><p>如何评价各个磁盘调度</p></div><ul><li>通常情况下，除非有很多请求在队列中，否则，各个算法<strong>没太大区别</strong></li><li>操作系统可以<strong>以执行效率为目的</strong>来按一定的策略放置文件<ul><li><strong>分布式系统</strong>把<u>频繁使用的文件</u>放在磁盘的中间位置</li><li><strong>Ext2文件系统</strong>把<u>inode节点</u>放在磁盘靠近他们所<u>表示的数据块</u>的附近。</li></ul></li></ul><h4 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h4><blockquote><p>作用</p><ul><li>通过<strong>并行</strong>提高性能</li><li>通过<strong>冗余</strong>提高可靠性</li></ul></blockquote><div class="note primary modern"><p>常用层次：RAID0,RAID1.RAID 5,RAID6</p></div><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406040007276.png" alt="image-20240604000729248" style="zoom:80%;" /></p><h3 id="磁盘调度器（Linux）"><a href="#磁盘调度器（Linux）" class="headerlink" title="磁盘调度器（Linux）"></a>磁盘调度器（Linux）</h3><h4 id="电梯调度器-Elevator"><a href="#电梯调度器-Elevator" class="headerlink" title="电梯调度器(Elevator)"></a>电梯调度器(Elevator)</h4><ul><li>使用电梯算法：队列以<strong>块号</strong>进行排序</li></ul><blockquote><p>有一个新的读写请求到达时，会依次考虑4个操作</p><ul><li>如果新请求与队列中的请求在<strong>同一磁盘扇区或相邻的扇区</strong>，则把新请求<strong>合并</strong>进队列</li><li>如果队列中的请求已经<strong>很长时间</strong>了，则新请求将被插入到<strong>队列尾部</strong></li><li>如果<strong>有合适位置</strong>，则新请求将被<strong>按顺序插入队列中</strong></li><li>如果<strong>没有合适的位置</strong>，则新请求将被插入队列的<strong>尾部</strong></li></ul></blockquote><font color="purple">什么叫“请求已经很长时间了”</font><h4 id="Linux-时限IO调度器"><a href="#Linux-时限IO调度器" class="headerlink" title="Linux-时限IO调度器"></a>Linux-时限IO调度器</h4><ul><li>作用：为了防止Linux Elevator出现<strong>长期延迟</strong>问题</li><li>采用3个队列：读请求同时存在于1，2队列中；写请求同时存在于1，3队列中<ul><li><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406040004661.png" alt="image-20240604000422642"></li></ul></li><li>读请求的<strong>默认时限</strong>是0.5秒，写请求5秒。</li></ul><h4 id="Linux-预期IO调度器"><a href="#Linux-预期IO调度器" class="headerlink" title="Linux-预期IO调度器"></a>Linux-预期IO调度器</h4><ul><li>对时限IO调度器的改进</li><li>根据“<strong>局部性</strong>”原理，磁盘请求往往相邻</li><li>当<strong>读请求</strong>被分派时，预期调度器的执行<u>将延迟6毫秒后再决定是否移动磁头到下一个位置</u></li></ul><h2 id="文件系统基本信息"><a href="#文件系统基本信息" class="headerlink" title="文件系统基本信息"></a>文件系统基本信息</h2><h3 id="早期不足"><a href="#早期不足" class="headerlink" title="早期不足"></a>早期不足</h3><details>    <summary>自行展开</summary>    <img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406040011374.png" alt="image-20240604001140344" style="zoom:67%;" /></details><blockquote><p>而后由个人向<strong>系统级</strong>发展，以系统调用的形式向应用程序提供<strong>数据管理服务</strong></p></blockquote><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>方便用户管理自己的数据资源</p><h4 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a><font color="red">基本要求</font></h4><ul><li>文件<strong>按名</strong>存储</li><li>文件有序组织，文件名<strong>分层次</strong>管理<ul><li>如支持树形目录结构</li></ul></li><li>操作简单，<strong>存取效率高</strong>。</li></ul><h4 id="其他要求"><a href="#其他要求" class="headerlink" title="其他要求"></a>其他要求</h4><ul><li>支持<strong>多用户系统</strong>，多用户能够<u>共享同一个磁介质</u></li><li>有一定的<strong>安全性</strong>保证，最好能进行<strong>数据恢复</strong></li><li>存储空间的<strong>利用率</strong>高</li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><strong>文件</strong>：由<u>文件名字</u>标识的一组相关信息的集合。<strong>文件名</strong>是<u>字母或数字</u>组成的字母数字串</li><li><strong>文件系统</strong>:<ul><li>软件观点：操作系统中，为用户和应用程序<u>管理文件</u>的<u>系统软件集合</u></li><li>存储格式观点：文件系统是文件在<u>存储介质上保存和管理相关的约定</u>。在操作系统中，这种约定的实现也被称为文件系统。一种相关约定就对应一种文件系统，所以目前存在多种文件系统：FAT，FAT32，NTFS，EXT2等</li></ul></li><li><strong>一个操作系统</strong>除支持为它设计的文件系统外，<strong>还可能支持其他文件系统</strong></li></ul><h4 id="文件的命名"><a href="#文件的命名" class="headerlink" title="文件的命名"></a>文件的命名</h4><ul><li>文件名是<strong>字母或数字</strong>组成的字母数字串，在一些文件系统中还可能包含其它字符，如<strong>下划线</strong>等</li><li>各种文件系统的文件命名规则略有不同，即文件名的<strong>格式和长度</strong>因系统而异。</li></ul><blockquote><p>长度包括文件路径</p></blockquote><h4 id="文件的类型"><a href="#文件的类型" class="headerlink" title="文件的类型"></a>文件的类型</h4><ul><li><strong>普通文件</strong>：即前面所讨论的<u>存储在外存设备上</u>的数据文件。</li><li><strong>目录文件</strong>：文件在管理普通数据文件时，需要保存其<u>相应的文件和属性</u>，这些属性以目录文件的形式存储在<u>磁盘</u>中。</li><li><strong>块设备</strong>文件：在<u>unix/Linux</u>等操作系统中，对应于<u>磁盘、光盘或磁带</u>等块设备的文件。</li><li><strong>字符设备</strong>文件：在<u>unix/Linux</u>等操作系统中，对应于终端、打印机等<u>字符设备</u>的文件</li></ul><h4 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h4><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406040026701.png" alt="image-20240604002658680" style="zoom:50%;" /></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>用户使用方便</strong>：只要知道文件名，可存取信息，实现了<u>“按名存取”</u></li><li><strong>安全可靠性</strong>：<ul><li>用户<u>通过文件系统才能</u>实现对文件的访问，故可防止对文件信息无意的破坏。</li><li>而文件系统能提供各种<u>安全、保密和保护</u>措施</li></ul></li><li><strong>数据共享</strong><ul><li>移动存储设备</li><li>各种形式的文件链接，不同的用户可以使用<u>同名或异名的同一文件</u></li></ul></li></ul><h3 id=""><a href="#" class="headerlink" title="#"></a>#</h3><h1 id="遗留作业"><a href="#遗留作业" class="headerlink" title="遗留作业"></a>遗留作业</h1><ol><li><p>磁盘调度</p><p><img src="https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406032358632.png" alt="image-20240603235836608" style="zoom:80%;" /></p></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
          <category> class </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> 2023-2024Spring </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/05/26/hello-world/"/>
      <url>/2024/05/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
