[{"id":"ae62d96c4d4b44da94c1e2f3ddf6dd43","title":"Web基础题","content":"GET/POST\r\n请用GET方式提交一个名为a,值为1的变量\r\nget方式提交比较容易，get传值方式参数可以存在URL中，题目中要求用get方式提交一个a=1的变量。\r\nURL后面加上 /？a=1 即可。\r\n请再以POST方式随便提交一个名为b,值为2的变量\r\npost传值方式不可以在URL中，而是通过request body传递参数。\r\n利用火狐浏览器的HackBar（付费）或者Max\r\nHackBar（免费）提交post请求b=2。\r\n一般form表单头用get方式都可以满足大多需求 但有一种情况，url里已经有值的时候，用url就会覆盖原来的值，而数据就会丢失。\r\n\r\n注意：不能直接将GET改为POST，需要Action中Change\r\nRequest Mode\r\nRobots协议\r\nRobots协议是一个位于网站根目录下的robots.txt文件，用来指示搜索引擎爬虫哪些页面可以访问，哪些页面禁止访问。通过遵守Robots协议，可以有效地控制搜索引擎爬虫的抓取行为，维护网站的合法权益。\r\n直接寻找robots.txt\r\n1website/robots.txt\r\n注意：robots协议的disallow文件类似于道德规范，仍然可以直接访问\r\nPHP文件\r\nPHP的备份\r\nphp的备份有两种：.php~和.php.bak\r\n指令\r\n\r\n网页组成\r\n不能按的按钮\r\n\r\n在elements中可以进行修改\r\nintruder\r\n攻击载荷破解\r\n\r\n","slug":"攻防view_source","date":"2024-06-24T16:04:00.000Z","categories_index":"study,CTF,基础","tags_index":"CTF,web攻击,基础题","author_index":"sensuschung"},{"id":"91e055873403cea6328235d978a7166d","title":"monad概览","content":"基本概念\r\n\r\nm类型构造子\r\nreturn :: a -&gt; M a：（也叫做unit），接受一个类型a的值，把它们包装成使用这个类型构造子建造的类型m a的“单子值”\r\nbind :: (M a) -&gt; (a -&gt; M b) -&gt; (M b)\r\n：也可写作\r\n&gt;&gt;=，接受一个在类型a上的函数f，并应用f于去包装的值a，转变单体值m a。\r\n\r\n通过以上元素，复合出一个函数调用的序列，在一个表达式中通过一些bind算子把它们链接起来。\r\n每个函数调用转变它的输入普通类型值，而bind算子处理返回的单子值，它被填入到序列中下一个步骤。\r\n示例\r\n案例：maybe\r\n\r\n需要显示定义函数的返回状态：Just ⌑result⌑, or\r\nNothing\r\n\r\n案例：\r\n123456fn divide(x: Decimal, y: Decimal) -&gt; Maybe&lt;Decimal&gt; &#123;    if y == 0 &#123; return Nothing &#125;    else &#123; return Just(x / y) &#125;&#125;// divide(1.0, 4.0) -&gt; returns Just(0.25)// divide(3.0, 0.0) -&gt; returns Nothing\r\n\r\n检查Maybe算子返回的值(上)或使用类型匹配（下）\r\n\r\n1234567let m_x = divide(3.14, 0.0); // see divide function above// The if statement extracts x from m_x if m_x is the Just variant of Maybeif let Just(x) = m_x &#123;    println!(&quot;answer: &quot;, x)&#125; else &#123;    println!(&quot;division failed, divide by zero error...&quot;)&#125;\r\n12345let result = divide(3.0, 2.0);match result &#123;    Just(x) =&gt; println!(&quot;Answer: &quot;, x),    Nothing =&gt; println!(&quot;division failed; we&#x27;ll get &#x27;em next time.&quot;),&#125;\r\n\r\n多输入monad，单输出monad\r\n\r\n12345678910fn chainable_division(maybe_x: Maybe&lt;Decimal&gt;, maybe_y: Maybe&lt;Decimal&gt;) -&gt; Maybe&lt;Decimal&gt; &#123;    match (maybe_x, maybe_y) &#123;        (Just(x), Just(y)) =&gt; &#123; // If both inputs are Just, check for division by zero and divide accordingly            if y == 0 &#123; return Nothing &#125;            else &#123; return Just(x / y) &#125;        &#125;,        _ =&gt; return Nothing // Otherwise return Nothing    &#125;&#125;chainable_division(chainable_division(Just(2.0), Just(0.0)), Just(1.0)); // inside chainable_division fails, outside chainable_division returns Nothing\r\n\r\n使用&gt;&gt;=来传递多次匿名函数；多参数处理\r\n\r\n123456halve :: Int -&gt; Maybe Inthalve x  | even x = Just (x `div` 2)  | odd x  = Nothing -- This code halves x twice. it evaluates to Nothing if x is not a multiple of 4halve x &gt;&gt;= halve\r\n\r\nx &gt;&gt;= y即把x传递给函数y获得返回值\r\n\r\n1chainable_division(mx,my) =   mx &gt;&gt;=  ( λx -&gt;   my &gt;&gt;= (λy -&gt; Just (x / y))   )\r\n\r\n在此处的\\(\\lambda\\)表示匿名函数\r\n\r\n在上面的案例中，有以下几种类型：\r\n\r\nMonadic Type：Maybe\r\nUnit operation（类型转换）：Just(x)\r\nBind operation（组合子）： &gt;&gt;= or\r\n.flatMap()\r\n\r\n标准定义\r\n构成\r\n\r\nA type\r\nconstructor M that builds up a monadic\r\ntype M T\r\ntype converter常被叫做 unit or\r\nreturn，用于将一个对象x嵌入到单子中，unit(x) :: T -&gt; M T\r\ncombinator\r\n典型的叫做bind，并表示为中缀算子&gt;&gt;=，去包装一个单体变量，接着把它插入到一个单体函数/表达式之中，结果为一个新的单体值：\r\n(&gt;&gt;=) : (M T, T → M U) → M Uso if\r\nmx : M T and f : T → M U, then\r\n(mx &gt;&gt;= f) : M U\r\n\r\n遵循定律\r\n\r\nunit是bind的左单比特 unit(x) &gt;&gt;= f\r\n↔︎ f(x)\r\nunit是bind的右单比特 ma &gt;&gt;= unit\r\n↔︎ ma\r\n\r\n\r\n此处左单比特、右单比特即单位元，identity\r\n\r\n\r\nbind符合结合律 ma &gt;&gt;= λx → (f(x) &gt;&gt;= g)\r\n↔︎ (ma &gt;&gt;= f) &gt;&gt;= g\r\n\r\n\r\n单子构成在函子（functor）范畴上的幺半群\r\n\r\n","slug":"monad概览","date":"2024-06-03T13:18:00.000Z","categories_index":"study,functional programming","tags_index":"function programming,monad","author_index":"sensuschung"},{"id":"e1111deafa6114c30ea11c8e9b534620","title":"NIS2334复习","content":"零碎知识点\r\nsignals and systems\r\nSa函数\r\n\r\n\r\nbasic signals\r\n\r\n\r\n\r\n\r\n\r\nunit impulse/unit step\r\n\r\n\r\n\r\n\r\n\r\n\r\nproperties\r\n\r\ntime shift\r\ntime reversal\r\ntime scaling\r\ncombination transformation\r\ndifferentiate\r\nintegar\r\n\r\nelse\r\nodd signals and even signals\r\n\r\n\r\n\r\nreal and imaginary part\r\n\r\nFS\r\nDTFS\r\n\r\n傅里叶级数是对信号在能量上的最佳近似\r\n\r\ngroup delay\r\n\r\n可能试题\r\nsignals and systems\r\nJudge period\r\nCT\r\n\r\nDT\r\n\r\n\r\nenergy and power\r\n\r\n\r\n\r\n(finite) Power signal：with infinite energy\r\n(finite) Energy signal：with zero average power\r\n\r\n\r\n\r\n\r\n例题\r\n\r\n\r\n\r\ncombination transformation\r\n\r\nsystem properties\r\ncausality\r\nstability\r\ntime\r\ninvariance\r\nlinearity\r\n--- how to prove\r\n十分钟搞定时变系统的判断_哔哩哔哩_bilibili\r\n\r\n变系数则为时变\r\n\r\nLTI\r\nconvolution\r\n\r\nimpulse response/shift impulse response\r\n\r\n公式\r\n\r\n\r\n冲激卷积\r\n\r\n\r\n方法\r\n\r\n图解法：【第37题】▏知识点：图解法计算卷积积分_哔哩哔哩_bilibili\r\n解析法\r\n\r\n速成\r\n\r\n\r\n\r\n利用冲激函数\r\n\r\n直接替换其中内容\r\n\r\n\\(n_1 + n_2\\)\r\n分配律/交换律/结合律\r\n\r\nscaling性质：左边成一个右边乘两个\\(\\frac{1}{a}\\)\r\n\r\n\r\n\r\n常见卷积\r\n\r\n门函数的卷积\r\n\r\n\r\n单位跃阶响应\r\n\r\ndifference 和defferential\r\n\r\n\r\n系统性质\r\n\r\ncasality:看\\(h(t)&lt;0\\)的部分\r\nstability:绝对可积\r\n\r\nlinear\r\nfunctions\r\ndifferential\r\n\r\nzero input/zs\r\nfree/force\r\n齐次解/特解\r\n\r\n方法\r\n\r\n经典解法\r\n\r\n特解：\r\n\r\n系统解法\r\n\r\n经典解法与系统解法_哔哩哔哩_bilibili\r\ndifference\r\n\r\n将y化为方程\r\n\r\n\r\n神奇的递归法\r\n\r\n\r\n\r\n\r\n例题\r\n\r\n\r\n\r\nFourier Series\r\nCTFS\r\n形式\r\n\r\n复指数形式\r\n\r\n\r\n\\(a_n\\)共轭对称\r\n\r\n三角形式\r\n\r\n余弦形式\r\n\r\n\r\n\r\n\r\n性质\r\n\r\nDTFS\r\n\r\nconvergence\r\n充分\r\n\r\nDirichlet conditions\r\n\r\nfinite maxima and minima\r\n\r\n\r\n\r\n\r\n\r\npaswell-energy\r\n\r\n频谱图？\r\nFT\r\ntransform pair\r\n\r\n\r\n\r\n\r\nconvergence\r\n\r\nCT:Dirichlet conditions\r\nDT:no problem\r\n\r\n变换\r\n\r\nexample\r\n\r\n\r\n\r\n\r\n\r\nduality\r\n\r\n\r\n\r\nsampling\r\n\r\n\r\nlaplace\r\n\r\n存在条件\r\n\r\nFT存在条件\r\n\r\nROC与x(t)\r\n\r\ninverse laplace\r\n\r\n\r\nPartial-fraction expansion\r\n\r\n相同实根\r\n复数根\r\n\r\n\r\n稳定和因果\r\n\r\n\r\n零状态响应\r\n\r\nblock diagrams\r\n\r\n\r\n\r\n\r\n单边LT\r\n\r\nZT\r\n\r\nFT存在\r\n\r\nROC\r\n\r\n\r\n\r\ninverse ZT\r\nuni lateral Z\r\n\r\nsquare signal\r\nFS coefficients\r\n\r\n","slug":"ICE2501_Review","date":"2024-06-02T14:16:00.000Z","categories_index":"study,class","tags_index":"review,2023-2024Spring,signals&systems","author_index":"sensuschung"},{"id":"ca59df81d26b019565ef81d82c38a865","title":"NIS2336","content":"概论\r\n概念\r\n\r\n翻译程序：源语言、源程序、目标语言、目标程序\r\n编译程序\r\n编译的两大（编译和运行)/三大阶段(编译、汇编和运行）及区别（编译阶段生成的目标程序）\r\n解释程序和编译程序的主要区别\r\n编译的六个阶段、前端和后端\r\n词法分析：源程序、字符串、扫描分解、单词/单词符号/符号\r\n语法分析：单词符号串、语法规则、识别语法单位、检查\r\n语义分析、中间代码生成：语法单位、静态语义省查、分析含义、\r\n另一种  语言描述（什么语言？）\r\n代码优化：对（）进行（）改造或变换，高效，主要包括（局部优化）和（循环优化）\r\n\r\n目标代码生成：将中间代码变换成（绝对指令代码）或（可重定位指令代码）或（汇编指令代码）\r\n\r\n在 每个\r\n过程中，涉及  表格管理和错误处理\r\n：表格的构造、查找、修改、存取\r\n\r\n\r\n判断\r\n\r\n上面的图中的流程是逻辑关系吗？是执行时间上的先后关系吗？可按照不同的执行流程来组织吗？\r\n\r\n相关：一遍扫描?多遍扫描？开始和结束？优缺点？\r\n\r\n编译程序：复杂系统程序\r\n\r\n文法和语言\r\n概念\r\n字母表和符号串\r\n\r\n字母表：含义、个数、类型\r\n符号/字符\r\n符号串：有穷、特定、空 \\(\\epsilon\\)，\\(|\\epsilon|=0\\)\r\n运算：符号串（连接、幂运算）集合（乘积-所有符号串、闭包、正闭包）\r\n\\(\\epsilon\\) 是空符号串，\\(\\{\\epsilon\\}\\) 是 \\(\\epsilon\\) 组成的集合， 不是空集合 ，\\(\\Phi=\\{\\}\\) 是空集合\r\n\r\n文法形式化\r\n\r\n形式语言（字母表、规则、符号串）、描述方法（枚举、文法）\r\n规则/产生式：终结符与非终结符\r\n文法：四元组（\\(V_N,V_T,P,S\\)）、字汇表（\\(V\\)）、关键、候选式与识别符号\r\n序列的集合成为形式语言\r\n形式语言  不考虑语义\r\n\r\n设计的文法不能超出所定义语言的范围\r\n\r\n推导与规约\r\n\r\n推导：\r\n\r\n直接推导（\\(xAy\\Rightarrow xay\\) 且 \\(A\\rightarrow a\\)）, 仅使用  一次  规则\r\n推导：\\(a_0\\xRightarrow{+}a_n\\)，长度为 n(\\(n\\gt 0\\))的推导\r\n广义推导：\\(a_0\\xRightarrow{*}a_n\\) 长度为 n(\\(n\\ge 0\\))\r\n\r\n句型与句子、语言（ 句子  的集合）\r\n最左推导/最右推导（规范推导）、规范句型\r\n最左规约（规范规约）/最右规约\r\n规则/文法的左递归/右递归/递归（哪一边不变？）\r\n文法给定，则语言确定，且 \\(L(G)\\subseteq V_T^*\\)\r\n文法的递归需要至少一步推导\r\n递归使得我们能用有限的规则定义无穷集合的语言\r\n\r\n语法树、短语、文法二义性\r\n\r\n语法树、子树、简单子树\r\n短语（终结符）、直接短语、句柄（最左直接短语）\r\n文法二义性：两个语法树/两个不同的最左或最右推导\r\n语言二义性/先天二义性（举例：\\(L=\\{a^i b^j c^k\r\n|i=j或j=k且i,j,k\\ge1\\}\\)）\r\n语法树和短语等的关系\r\n\r\n短语：子树的末端结点符号串是相对于子树根的短语\r\n直接短语：简单子树的末端结点符号串是相对于简单子树根的短语\r\n句柄：最左简单子树的末端结点形成的符号串\r\n\r\n短语、直接短语和句柄是针对某一句型的\r\n\r\n文法和语言的分类\r\n\r\n0型文法/无限制文法/无限制语言\r\n1型文法/上下文有关文法\r\n2型文法/上下文无关文法\r\n3型文法/正规文法/左右线型文法/正规语言（展开的是哪里的终结符?留下的是哪里的非终结符？）\r\n正规文法\\(\\subseteq\\)上下文无关\\(\\subseteq\\)上下文有关\\(\\subseteq\\)无限制\r\n文法限制：有害规则、多余规则\r\n\r\n判断\r\n\r\n形式语言考虑语义。（x）\r\n每个非终结符表示一定符号串的集合。（√）\r\n推导的依据是  规则 (√)\r\n当一个语言是无穷集合时，定义该语言的文法不一定是递归的。（×）\r\n\r\n题型\r\n文法的设计\r\n\r\n根据字母表设计文法\r\n\r\n\r\n相同的幂必须合并在一起\r\n\r\n例题：设字母表 \\(\\Sigma=\\{a,b\\}\\)，尝试设计一个文法描述语言\r\n\\(L=\\{a^n b^n|n\\ge 0\\}\\)\r\n解：\r\n\\(V_T=\\{a,b\\}\\\\V_N=\\{L\\}\\\\P=\\{L\\rightarrow\\epsilon|aLb\\}\\\\S=L\\)\r\n证明是句型、句子\r\n\r\n证明有相应的推导即可\r\n\r\n例题：设有文法 \\(G[E]:E\\rightarrow\r\nE+E|E*E|(E)|i\\)，尝试证明符号串 \\((i*i+i)\\) 是 \\(G[E]\\) 的一个句子\r\n解：\\(E \\Rightarrow\r\n(E)\\Rightarrow(E+E)\\Rightarrow(E*E+E)\\Rightarrow(i*E+E)\\Rightarrow(i*i+E)\\Rightarrow(i*i+i)\\)\r\n从已知文法确定语言\r\n\r\n中心思想: 从开始符号出发, 反复使用规则, 对非终结符施行替换和展开\r\n\r\n例题: \\(G[S]:S\\rightarrow 01|0S1\\)\r\n解答：\\(L(G[S])={0^n1^n|n\\ge 1}\\)\r\n推导与规约\r\n\r\n最左推导与最右推导示例\r\n\r\n例题：设文法 \\(G[S]:S\\rightarrow AB;\r\nA\\rightarrow A0|1B;B\\rightarrow 0|S1\\) 给出句子 101001\r\n的最左和最有推导\r\n最右推导： \\[\r\n\\begin{aligned}\r\nS &amp;\\Rightarrow AB \\Rightarrow AS1 \\Rightarrow AAB1 \\Rightarrow\r\nAA01\\\\\r\n&amp;\\Rightarrow A1B01 \\Rightarrow A1001 \\Rightarrow 1B1001\r\n\\\\&amp;\\Rightarrow101001\r\n\\end{aligned}\r\n\\] 最左推导： \\[\r\n\\begin{aligned}\r\nS &amp;\\Rightarrow AB \\Rightarrow 1BB \\Rightarrow 10B \\Rightarrow 10S1\\\\\r\n&amp;\\Rightarrow 10AB1 \\Rightarrow 101BB1 \\Rightarrow 1010B1\r\n\\\\&amp;\\Rightarrow101001\r\n\\end{aligned}\r\n\\]\r\n求短语、直接短语、句柄\r\n\r\n通过推导关系建立语法树，从而求出上述内容\r\n\r\n例题：设有文法\\(G[S]=(\\{S,A,B\\},\\{a,b\\},P,S)\\)，求出句型\\(baSb\\)的短语、直接短语和句柄，其中\\(P\\)为： \\[\r\nS \\rightarrow AB\\\\\r\nA \\rightarrow Aa|bB\\\\\r\nB \\rightarrow a|Sb\r\n\\] 列出子树：\r\n\r\n则短语为：\\(a,ba,Sb,baSb\\)，直接短语为\\(a\\)，句柄为\\(a\\)\r\n注意：直接短语直接找只有一个叶子结点的子树，句柄找最左边的直接短语\r\n消除文法二义性\r\n\r\n1.定义优先级，左右结合性\r\n2.构造无二异性文法\r\n\r\n例：构造无二义性文法，使得\\(*\\)优先级高于\\(+\\)\r\n定义文法如下：（层层递推） \\[\r\nEXPR1 \\rightarrow EXPR2*EXPR2|EXPR2\\\\\r\nEXPR2 \\rightarrow EXPR3+EXPR3|EXPR3\\\\\r\nEXPR3 \\rightarrow (EXPE1)\r\n\\] 说明文法二义性：画出两颗不同的语法树即可\r\n词法分析\r\n概念\r\n单词符号与定义方式\r\n单词符号\r\n\r\n单词符号（独立、最小语法单位）：关键字、标识符、常数、运算符、界符\r\n单词符号二元式（种类、值）\r\n\r\n正规式与正规集\r\n\r\n简单正规式：\\(\\Phi\\)（空集）、\\(\\epsilon\\)（空符号串 $ {}\\(）、\\)a_i\\(（\\){a_i}$）\r\n规则：\\(e_1|e_2\\)、\\(e_1\r\ne_2\\)、\\(e_1^*\\)（左结合，优先级：闭包&gt;连接&gt;或）\r\n正规式的性质：交换律、结合律、分配律、单位元、闭包运算\r\n不能用正规文法表示的不能算作正规集\r\n注意正规式与正规文法的区别和联系\r\n\r\n有穷自动机\r\n\r\n五元组（Q，\\(\\Sigma\\)，f，S，Z）(f和S在NFA和DFA中的不同含义）\r\n状态转移矩阵与状态转换图\r\n\r\n\r\n被识别/被接受、DFA\r\nM识别的语言\r\n利用自动机构造词法分析程序的流程\r\n对于每个NFA M，存在DMA M’，使得L(M)=L(M’)\r\n\r\n题型\r\n由正规式求正规集\r\n\r\n可以用枚举法或者形式化语言表示\r\n注意化为形式化语言时，或、闭包、连接运算怎么转换\r\n\r\n枚举法\r\n\\(ba^*:L(ba^*)=L(b)L(a^*)=\\{b,ba,baa,\\dots\\}\\)\r\n形式化语言\r\n\\((a|b)^*(aa|bb)(a|b)^*:\\)\r\n\\(L((a|b)^*(aa|bb)(a|b)^*)=L((a|b)^*)L(aa|bb)L((a|b)^*)=\\{a,b\\}^*\\{aa,bb\\}\\{a,b\\}^*\\)\r\n由正规文法求正规集\r\n\r\n\r\n列出联立方程式：\\(x=\\alpha x|\\beta\r\n\\Rightarrow x=\\alpha^*\\beta\\)以及\\(x=x\\alpha|\\beta \\Rightarrow\r\nx=\\beta\\alpha^*\\)\r\n通过分配交换结合律解方程\r\n\r\n\r\n例题：求中的正规式\r\n\r\n\r\n首先，列出方程（将或运算变为加号）\r\n\r\n然后依次带入求解\r\n\r\n\r\n最后化为正规式\r\n\r\n\r\n由正规式求正规文法\r\n\r\n到G的转换如下\r\n\r\n\\(V_T=\\Sigma\\)\r\n\\(S=Z\\rightarrow R\\)\r\n\\(A\\rightarrow ab: A\\rightarrow aB,B\r\n\\rightarrow b\\)\r\n\\(A\\rightarrow a^*b :A\\rightarrow\r\naA|b\\)\r\n\r\n\r\n例子：将\\(R=(a|b)(aa)^*(a|b)\\)转化为正规文法\r\n\r\n每一个推导式中只能出现一个非终结符\r\n由正规式求NFA\r\n步骤\r\n\r\n引入初始节点和终止节点\r\n\r\n对于基本符号构造NFA\r\n\r\n\r\n对于复合正规式构造节点\r\n\r\n\r\n由NFA求DFA\r\n子集法\r\n画出状态矩阵以及确定化DFA图\r\n\r\n求状态集合，得到某字符+空串能到达的状态。若不同，则为新状态\r\n\r\nDFA的化简\r\n\r\n没有多余状态和等价状态\r\n\r\n\r\n划分终态集和非终态集。\r\n路径化简，按路径化简划分集合，若为已有集合的子集，则不用划分，若不为已有集合的子集，则需要划分\r\n\r\n参考：DFA化简\r\n一看就会 自己和解_哔哩哔哩_bilibili\r\n\r\n答题的时候用官方语言描述：\r\n\r\n\r\n有穷自动机转为正规式\r\n\r\n增加X节点和Y节点，X连结到所有初态，Y连结到所有终态\r\n逐步消去M’中的其他结点，消除方式如下：\r\n\r\n\r\n正规文法与有穷自动机的转换\r\n右线性正规文法转有穷自动机\r\n\r\n获取Q:\\(V_N+D\\)，Z:\\(D\\)，\\(\\Sigma:V_T\\)，\\(q_0:S\\)\r\n\\(A \\rightarrow aB \\Rightarrow\r\nf(A,a)=B\\)\r\n\\(A \\rightarrow a \\Rightarrow\r\nf(A,a)=D\\)\r\n\\(A \\rightarrow \\epsilon \\Rightarrow\r\nf(A,\\epsilon)=D\\)\r\n\r\n左线性正规文法转有穷自动机\r\n\r\n获取Q:\\(V_N+q_0\\)，Z:\\(S\\)，\\(\\Sigma:V_T\\)，\\(q_0:q_0\\)\r\n\\(A \\rightarrow Ba \\Rightarrow\r\nf(B,a)=A\\)\r\n\\(A \\rightarrow a \\Rightarrow\r\nf(q_0,a)=A\\)\r\n\r\n有穷自动机到正规文法\r\n\r\n\\(V_N =\r\nQ,V_T=\\Sigma,S=q_0\\)\r\n\\(f(A,a)=B,B\\notin Z \\Rightarrow A\r\n\\rightarrow aB\\)\r\n\\(f(A,a)=B,B\\in Z \\Rightarrow A\r\n\\rightarrow aB|a,B\\rightarrow \\epsilon\\)\r\n\\(S\\)为终态 \\(\\Rightarrow S \\rightarrow\r\n\\epsilon\\)\r\n\r\n在化简时要注意有没有多余状态：只进不出\r\n语法分析\r\n概念\r\n\r\n自上而下、自下而上分析方法、非确定性自上而下，确定的自上而下（无左递归、无回溯）\r\n回溯的原因（右部左端第一个符号相同、某一右部推出空串）\r\nLL1文法（无回溯）\r\n递归下降分析法（非终结符、函数、LL1）\r\n预测分析法：构输入缓冲区、分析栈、预测分析表、预测分析器\r\n自下而上的原理（移进、规约）（可规约串的选取、句柄-规范规约/最左素短语-算符优先级）\r\n优先级分析法：优先关系表、算符文法（非终结符相邻）；算符优先文法OPG（不含\\(\\epsilon\\)规则、一种关系成立）\r\n算符优先分析法不是一种规范归约的分析方法\r\n最左素短语（\\(\\ge\\)一个终结符），不包含其他素短语\r\nLR语法；LR分析表；移进/归约/接受/报错、规范句型活前缀、归约项目、移进项目、待约项目、接受项目；句柄识别态，接受状态，项目集规范族\r\n\r\n题型与方法\r\n左递归/提取公因子\r\n左递归的消除 \\[\r\nA \\rightarrow\r\nA\\alpha_1|A\\alpha_2|\\dots|A\\alpha_m|\\beta_1|\\beta_2|\\dots|\\beta_n\r\n\\] 修改为： \\[\r\nA \\rightarrow \\beta_1A&#39;|\\beta_2A&#39;\\dots|\\beta_nA&#39;\\\\\r\nA&#39;\\rightarrow\r\n\\alpha_1A&#39;|\\alpha_2A&#39;|\\dots|\\alpha_mA&#39;|\\epsilon\r\n\\] 提取公因子 \\[\r\nA\\rightarrow \\alpha\\beta_1|\\alpha\\beta_2|\\dots|\\alpha\\beta_n\r\n\\] 提取后得到： \\[\r\nA\\rightarrow aA&#39;\\\\\r\nA&#39; \\rightarrow \\beta_1|\\beta_2|\\dots|\\beta_n\r\n\\]\r\n\r\n将非LL(1)转为LL（1）的过程中可能会遇到隐式公共左因子，需要先代入\r\n\r\nLL(1)文法的判定\r\nFIRST集合\r\n由\\(\\alpha\\)可以推导出所有的首终结符或者可能的\\(\\epsilon\\)\r\nFOLLOW集合\r\nA后面的所有终结符或\\(\\$\\)\r\nSELECT集合 \\[\r\nSELECT(A\\rightarrow \\alpha)=\r\n\\begin{cases}\r\nFIRST(\\alpha)&amp;,a\\nRightarrow \\epsilon\\\\\r\nFIRST(\\alpha)\\setminus{\\epsilon}\\cup FOLLOW(A)&amp;,a\\xRightarrow{*}\r\n\\epsilon\r\n\\end{cases}\r\n\\] 判断条件 \\[\r\nSELECT(A\\rightarrow \\alpha)\\cap SELECT(A\\rightarrow \\beta)=\\Phi\r\n\\]\r\n预测分析法\r\n预测分析表的构造\r\n\r\n首先需要判断是否为LL(1)文法\r\n\r\n\r\n计算\\(FIRST\\)集和\\(FOLLOW\\)集\r\n\\(A\\rightarrow \\alpha,\\alpha \\in\r\nFIRST(A)\\)，则\\(M[A,a]=A\\rightarrow\r\n\\alpha\\)\r\n\\(\\epsilon \\in FIRST(A)\\)则对\\(\\forall b\\in FOLLOW(A),M[A,b]=A\\rightarrow\r\n\\alpha\\)\r\n未定义内容用空白格表示\r\n\r\n预测分析表作用于预测分析器\r\n\r\n算符优先级分析法\r\n终结符优先级的定义\r\n\r\n\\(a=b: P\\rightarrow\\dots\r\nab\\dots\\)或\\(P\\rightarrow\\dots\r\naQb\\dots\\)\r\n\\(a\\lessdot b:P\\rightarrow \\dots\r\naR\\dots\\)且\\(R\\xRightarrow{+}Qb/b\\dots\\)\r\n\\(a\\gtrdot b:P\\rightarrow \\dots\r\nRb\\dots\\)且\\(R\\xRightarrow{+}aQ/a\\dots\\)\r\n越包含在里面，在语法树中层级越偏下，优先级越高\r\n\r\n构造FIRSTVT集 \\[\r\nFIRSTVT(A)=\\{b|A\\xRightarrow{+}b\\dots or A\\xRightarrow{+}Bb\\dots \\}\r\n\\] 构造LASTVT集 \\[\r\nLASTVT(A)=\\{a|A\\xRightarrow{+}\\dots a or A\\xRightarrow{+}\\dots aB \\}\r\n\\] 构造表格\r\n\r\n终结符在左，非终结符在右：终结符\\(\\lessdot\\)非终结符的\\(FIRSTVT\\)集\r\n终结符在右，非终结符在左：非终结符的\\(LASTVT\\)集\\(\\lessdot\\)终结符\r\n终结符在左右-&gt;相等\r\n对于S，\\(\\$\\lessdot FIRSTVT,LASTVT\r\n\\gtrdot\\$,\\$=\\$\\)\r\n\r\n最左素短语的判断\r\n(太困了，不想写)\r\n\r\n\r\n左右的非终结符也属于素短语\r\n\r\n分析过程\r\n\r\nLR(0)的构造\r\n主要内容\r\n\r\nCLOSURE的构造（后一个非终结符的展开）\r\nGO函数构造（点的移动+闭包构造）\r\n重复GO直至不出现新的状态集\r\n\r\nLR分析表的构造\r\n\r\n用0~n表示初始状态\r\nACTION：未结束且接受终结符\r\nGOTO：接受非终结符\r\nACTION\\(r_j\\)：已经可归约；终结符或结束符纪\r\nacc：S结束，相对于\\(\\$\\)\r\n\r\n\r\nSLR(1)文法\r\n\r\n在状态中又有移进项目，又有归约项目\r\n比LR(0)多求一个FOLLOW集\r\n将reduce行求出对应文法FOLLOW集，只给FOLLOW集写reduce即可\r\n\r\n怎么确定SLR(1)\r\n符号和FOLLOW集交集是否为空串\r\nLR(1)文法\r\n寻找向前搜索符\r\n\r\n为空，照抄\r\n不为空，加入FIRST集\r\n\r\n","slug":"NIS2336","date":"2024-06-02T14:16:00.000Z","categories_index":"study,class","tags_index":"review,2023-2024Spring,compiling","author_index":"sensuschung"},{"id":"9d95c27b9e5cf5edf293baff1f7390d5","title":"NIS2334","content":"可能考点！！！！！！\r\n1.计算题：\r\n\r\n扇区读写时间\r\n信号量\r\n周转时间\r\n\r\n2.重点\r\n\r\n概述\r\n\r\nspooling\r\n缓冲/中断/DMA\r\n操作系统的特征\r\n操作系统的功能\r\n操作系统的概念\r\n并发\r\n脱机/假脱机\r\n\r\n进程和线程\r\n\r\n进程调度算法\r\n线程基本理解（用户级、内核级、混合级）\r\n同步和互斥\r\n调度层次\r\n进程思索条件\r\n调度死锁处理：银行家、coffman\r\n生产者-消费者程序\r\nPV操作\r\n\r\n内存管理\r\n\r\n局部性原理，对虚拟分段、多级分页、虚拟分页、虚拟段页式影响\r\n虚拟地址与物理地址转换\r\n多级页表\r\n系统抖动及页面淘汰算法\r\n\r\n设备和文件\r\n\r\n机械盘为什么慢\r\n磁盘调度\r\nnode，文件大小\r\n打开文件接口，文件控制表\r\nIO标准库\r\n\r\n综合\r\n\r\n局部性原理\r\n中断处理程序、信号、陷阱\r\n\r\n\r\n简介\r\n基本概念\r\n设计目标\r\n\r\n方便：作为用户/计算机接口的操作系统\r\n有效：作为资源管理器的操作系统\r\n扩展能力：操作系 统的易扩展性\r\n\r\n硬件升级、新型硬件\r\n新服务\r\n纠正错误（打补丁）\r\n\r\n\r\n地位和作用\r\n\r\n屏蔽底层硬件的细节\r\n驱动、管理硬件设备\r\n给应用程序提供服务\r\n\r\n操作系统概念\r\n\r\n用户观点——用户使用计算机的界面\r\n\r\n命令方式\r\n系统调用\r\n图形界面\r\n\r\n软件观点——程序和数据结构的集合\r\n\r\n系统工具:shell、系统管理\r\nOS库（I/O）\r\n\r\n\r\n\r\n操作系统是控制和管理计算机系统内各种硬件和软件资源、有效地组织多道程序运行的系统软件（或程序集合），是用户与计算机之间的接口。\r\n\r\n\r\n\r\n是软件，且是系统软件\r\n基本职能是控制和管理系统资源\r\n提供服务，方便用户使用\r\n\r\n\r\n作业与进程\r\n作业\r\n\r\n作业（一个完整的任务，可能包括多个程序）\r\n作业步（作业中相对独立的部分）\r\n\r\n进程\r\n\r\nUNIX系统上的进程定义为程序在一个数据集合上的运行活动，它是系统进行资源分配和调度的一个可并发执行的独立单位。进程和程序之间既有区别又有联系。\r\n\r\n操作系统的特征\r\n并发（Concurrence）\r\n\r\n在一段时间内，多个程序同时在运行。\r\n并发与并行的区别\r\n\r\n\r\n任务执行方式：\r\n\r\n并行：\r\n并行处理要求系统具有多个处理单元，这些单元可以同时执行不同的任务。每个任务都在独立的处理单元上运行，彼此之间互不干扰。这种方式能够充分利用硬件资源，加速任务的完成。\r\n并发：\r\n并发处理强调任务的交替执行或重叠执行。即使系统只有一个处理单元，也可以通过任务间的切换，使得看似同时运行多个任务。并发更关注任务之间的协作和调度，以确保系统的效率和响应性。\r\n\r\n目标：\r\n\r\n并行：\r\n并行的主要目标是通过同时执行多个任务来提高整体性能。这通常涉及到将大任务划分为小的子任务，每个子任务由不同的处理单元执行，最终合并它们的结果。\r\n并发：\r\n并发的目标是更好地管理多个任务之间的关系，以确保它们能够有效地协同工作。并发处理通常用于处理实时性要求不高的任务，强调任务之间的逻辑结构和相互影响。\r\n\r\n\r\n共享（Sharing）\r\n\r\n互斥共享：打印机，写数据\r\n同时共享：磁盘，只读数据\r\n\r\n虚拟\r\n\r\n目的：为裸机提供高级抽象服务，虚拟出功能更强大的虚拟服务。\r\n例子：分时系统；SPOOLING\r\n\r\n不确定性\r\n\r\n同样一个数据集的同一个程序在同样的计算机环境下运行，其执行顺序和所需时间都不相同。\r\n\r\n现代操作系统的新特征\r\n\r\n\r\n现代操作系统的新特征\r\n\r\n\r\n微内核体系结构：微内核体系结构将操作系统的基本功能（如内存管理、进程管理、通信等）最小化，并将其他功能移到用户空间。这种设计提高了系统的可扩展性和稳定性，因为内核的代码量减少，从而降低了出错的可能性。\r\n\r\n\r\n多线程：多线程允许一个进程内的多个线程并行执行，每个线程共享进程的资源但有独立的执行路径。这提高了应用程序的响应速度和处理能力，尤其在多处理器系统中表现尤为明显。\r\n\r\n\r\n对称多处理（SMP）：对称多处理支持多个处理器共享同一内存和I/O资源，处理器之间可以并行执行任务。这种架构简化了多处理器系统的设计和实现，提升了系统的性能和扩展能力。\r\n\r\n\r\n分布式：分布式操作系统使得资源和服务可以分布在多个网络节点上，并通过网络进行协作。它提供了对分布式计算资源的统一管理和访问，使得用户和应用程序能够透明地使用远程资源。\r\n\r\n\r\n面向对象设计：面向对象设计方法将系统功能和资源抽象为对象，通过继承和多态性提高了代码的重用性和可维护性。现代操作系统利用这种设计方法简化了系统的扩展和修改。\r\n\r\n\r\n微内核体系结构\r\n\r\n单体内核（monolithic kernel）\r\n\r\n系统由大内核构成，该内核提供的功能：调度、文件系统、网络、设备驱动程序、存储管理等\r\n大内核作为一个进程实现，所有元素共享相同的地址空间\r\n\r\n微内核（micro kernel）\r\n\r\n内核仅具有基本功能：地址空间、进程通信和基本调度。\r\n‘其他的操作系统服务都由运行在用户模式下进程提供。\r\n优点：\r\n\r\n内核和服务分开，可以订制服务；\r\n体系结构更简单灵活，适合于分布式环境\r\n\r\n\r\n多线程\r\n\r\n线程：可分派工作单元。包括：处理器上下文、栈中自己的数据区域。\r\n进程：一个或多个线程及其相关系统资源的集合。\r\n优点：\r\n\r\n方便处理独立任务（如监听服务）\r\n线程间切换开销小\r\n\r\n\r\n\r\n\r\n线程和进程的区别\r\n\r\n\r\n定义：\r\n\r\n\r\n\r\n进程（Process）：进程是程序的一次执行实例，是操作系统进行资源分配和调度的基本单位。每个进程都有独立的内存空间和系统资源。\r\n\r\n\r\n线程（Thread）：线程是进程内的一个执行单元，是程序执行的最小单位。线程共享进程的内存空间和资源，但有独立的执行路径和局部变量。\r\n\r\n\r\n\r\n内存空间：\r\n\r\n\r\n\r\n进程：每个进程有独立的地址空间，一个进程崩溃不会影响其他进程。\r\n\r\n\r\n线程：同一进程内的线程共享相同的地址空间，一个线程崩溃可能导致整个进程崩溃。\r\n\r\n\r\n\r\n通信方式：\r\n\r\n\r\n\r\n进程：进程之间的通信需要通过操作系统提供的进程间通信（IPC）机制，如管道、消息队列、共享内存等。\r\n\r\n\r\n线程：线程之间可以直接通过共享内存进行通信，通信开销较低。\r\n\r\n\r\n\r\n资源开销：\r\n\r\n\r\n\r\n进程：创建和销毁进程的开销较大，因为需要分配和回收独立的内存和资源。\r\n\r\n\r\n线程：创建和销毁线程的开销较小，线程间切换的开销也比进程间切换小。\r\n\r\n\r\n\r\n调度：\r\n\r\n\r\n\r\n进程：操作系统独立调度进程，每个进程可以在不同的处理器上运行。\r\n\r\n\r\n线程：操作系统独立调度线程，同一进程内的线程也可以在不同的处理器上运行，支持并行执行。\r\n\r\n\r\n\r\n应用场景：\r\n\r\n\r\n\r\n进程：适用于需要强隔离、独立运行的任务，如不同的应用程序。\r\n\r\n\r\n线程：适用于需要高效并发、共享数据的任务，如多线程服务器、并行计算。\r\n\r\n\r\n\r\n对称多处理SMP\r\n基本要求：\r\n\r\n多个处理器\r\n共享主存储器和IO设备\r\n处理器都可以执行相同的功能\r\n\r\n优势\r\n\r\n性能（优于单处理器）\r\n可用性（鲁棒性）\r\n（性能）可增量发展\r\n（产品）可扩展性\r\n\r\n\r\n\r\n为什么SMP具有产品可扩展性\r\n\r\n\r\n共享内存架构：\r\n\r\n\r\n\r\n简单易扩展：\r\nSMP系统中的所有处理器共享同一块物理内存和I/O设备。当增加新的处理器时，只需将其连接到共享内存总线上，无需改变现有系统的架构和数据流。\r\n\r\n\r\n一致性和简单性：\r\n共享内存模型使得所有处理器都能访问相同的内存地址空间，这简化了开发和调试过程，因为程序员可以依赖于内存的一致性。\r\n\r\n\r\n\r\n并行处理能力：\r\n\r\n\r\n\r\n提高性能：\r\n通过增加更多的处理器，SMP系统可以并行处理更多任务，提高系统的整体性能和吞吐量。增加处理器的过程相对直接，只需配置新的处理器即可。\r\n\r\n\r\n负载均衡：\r\nSMP操作系统能够智能地将任务分配给不同的处理器，确保系统资源得到充分利用，并防止某个处理器过载。这种动态负载均衡能力使得系统能平稳扩展。\r\n\r\n\r\n\r\n标准化和兼容性：\r\n\r\n\r\n\r\n硬件兼容性：\r\nSMP系统通常使用标准化的硬件组件，如通用的处理器和内存模块。这种标准化的设计使得添加新处理器变得简单且具有成本效益。\r\n\r\n\r\n软件兼容性：\r\nSMP操作系统和应用软件通常设计为支持多处理器环境，这意味着现有的软件可以在扩展后的SMP系统上无缝运行，无需进行重大修改。\r\n\r\n\r\n\r\n容错能力和可靠性：\r\n\r\n\r\n\r\n高可用性：\r\n通过冗余配置多个处理器，SMP系统可以在某个处理器故障时继续运行，提升系统的可靠性和容错能力。增加处理器可以进一步增强这种容错能力。\r\n\r\n\r\n简化维护：\r\n由于处理器是模块化的组件，扩展和更换处理器变得相对简单，维护和升级也更加方便。\r\n\r\n\r\n\r\n经济效益：\r\n\r\n\r\n\r\n成本效益：\r\n由于SMP系统采用标准化组件，扩展系统的成本相对较低。企业可以根据需要逐步增加处理器，而不必一次性投入大量资金。\r\n\r\n\r\n灵活投资：\r\n企业可以根据实际需求逐步扩展处理能力，而无需提前为未来的需求进行大量投资，这种灵活性有助于降低初始成本和投资风险。\r\n\r\n\r\n\r\n分布式\r\n多机系统好像具有一个单一的主存空间、辅存空间以及其他统一的存取措施。\r\n\r\n\r\n现代操作系统的分布式特征\r\n\r\n\r\n资源共享：\r\n现代分布式操作系统能够管理和协调分布在不同网络节点上的资源，使得这些资源可以在整个网络中共享和访问。这包括处理能力、存储资源、数据和设备等。\r\n\r\n\r\n透明性：\r\n分布式操作系统隐藏了系统的分布性和复杂性，使得用户和应用程序可以像访问本地系统一样访问分布式系统的资源和服务。透明性包括位置透明性、访问透明性、迁移透明性和复制透明性等。\r\n\r\n\r\n可靠性和容错性：\r\n通过冗余和故障检测机制，分布式操作系统可以在某些节点或资源发生故障时继续提供服务，从而提高系统的可靠性和容错性。这通常包括数据备份、自动故障恢复和负载均衡等。\r\n\r\n\r\n并行处理：\r\n分布式操作系统支持并行处理，通过将任务分割成多个子任务并分配给不同的节点执行，从而提高系统的处理能力和效率。这对于大规模计算和复杂数据处理任务尤为重要。\r\n\r\n\r\n扩展性：\r\n分布式操作系统可以通过增加新的节点来扩展系统的容量和性能，支持应对不断增加的用户请求和数据处理需求。系统能够动态添加或移除节点，保持系统性能和资源的高效利用。\r\n\r\n\r\n一致性和协调：\r\n分布式操作系统提供一致性协议和协调机制，以保证分布式环境中数据的一致性和操作的同步。常用的一致性模型包括强一致性、最终一致性等。\r\n\r\n\r\n分布式文件系统：\r\n分布式操作系统通常包含分布式文件系统，使得文件可以跨越多个节点存储和访问，从而提高数据的可用性和可靠性。用户可以透明地访问和管理分布式文件。\r\n\r\n\r\n面向对象设计\r\n特点\r\n\r\n方便地添加模块\r\n方便定制操作系统\r\n促进了分布式工具和分布式操作系统的开发。\r\n\r\n## 缓冲、中断与DMA \r\n主要解决问题\r\n\r\n缓冲技术\r\n\r\n处于CPU 和 外设之间， 解决速度不匹配问题\r\n例如，spooling\r\n\r\n中断技术\r\n\r\n解决 CPU 和 外设的协调\r\n(不再需要轮询外设状态)\r\n\r\nDMA技术\r\n\r\n数据转移过度消耗CPU资源的问题，进一步解放CPU\r\n\r\n\r\n中断\r\n\r\n现代所有CPU都支持中断\r\n用于提高处理器的利用率\r\n\r\n\r\n不同类型\r\n\r\nI/O\r\n硬件错误、失效\r\n软件错误（栈溢出、非法指令等）\r\n定时器中断\r\n\r\n\r\nDMA\r\n\r\n驱动程序设定传输数据的长度、源地址与目的地址\r\nDevice启动DMA传输，完成所有数据的传输\r\n数据传输完成时DMA 设备产生中断\r\n\r\n\r\n基本原理\r\nDMA技术的基本原理是将数据传输的控制交给一个专门的DMA控制器，该控制器不需要CPU的干预，可以直接对内存和I/O设备进行访问和传输。这个过程中，CPU只需启动DMA控制器，并在数据传输完成后得到一个中断信号，表明数据已经传输完毕。这样就可以达到高效率、低CPU负载的目的\r\n\r\n\r\n优点\r\n\r\n把比较固定的任务让DMA来做，可以减轻CPU负担，提高系统的效率\r\nDMA具有一般CPU没有的高效操作，提高系统的吞吐率；消除了每次只能传输一个数据的限制，传输效率提高\r\n\r\n\r\n批处理\r\n\r\n\r\n批处理概述\r\n\r\n\r\n批处理是一种计算机操作系统中的自动化技术，用于批量处理多个命令或任务。其主要特点包括：\r\n\r\n\r\n\r\n自动化执行：批处理允许用户将一系列的命令或任务按顺序组织在一个批处理文件中，然后通过执行该文件来自动化执行这些命令，而无需用户手动逐个输入和执行。\r\n\r\n\r\n批量处理：通过批处理，用户可以一次性处理多个任务或操作，这些任务可以是复制文件、备份数据、运行程序等，从而提高操作效率和减少手动操作的重复性。\r\n\r\n\r\n脚本语言支持：通常使用特定的脚本语言编写批处理文件，如Windows中的批处理文件（.bat文件）或Linux/Unix中的Shell脚本，这些脚本语言提供了控制流程、变量、循环等编程结构，使得批处理更加灵活和强大。\r\n\r\n\r\n批处理调度：批处理可以通过系统的调度器（如Windows任务计划程序）定时执行，也可以在特定条件满足时触发执行，从而实现自动化的后台任务管理。\r\n\r\n\r\n\r\n总体而言，批处理技术通过自动化和批量处理的方式，帮助用户简化和加快了日常计算机操作和管理任务的执行过程。\r\n\r\n\r\n多道程序设计\r\n进一步提高CPU的利用率\r\n\r\n基本原理\r\n​\r\n允许多个程序（作业）同时进入一个计算机系统的内存并启动进行交替计算的方法，也就是，计算机中可以同时存放多道程序，从宏观上来看它们是并行的，多道程序都同时处于运行过程中，但都未运行结束，但是微观上是串行的，轮流占用CPU交替执行，引入多道程序设计技术的根本目的是提高CPU的利用率，充分发挥计算机系统部件的并行性\r\n总结利弊\r\n\r\n提高了CPU的利用率\r\n提高了内存和I/O设备的利用率\r\n改进了系统的吞吐率\r\n充分发挥了系统的并行性\r\n主要缺点是延长了作业周转时间\r\n\r\nSPOOLING\r\n为什么需要SPOOLING\r\n\r\n受限于IO的作业，输出缓冲满，而输入空\r\n受限于CPU的作业，输入缓冲区满，而输出空\r\n\r\n\r\n什么是SPOOLing技术 SPOOLing\r\n技术就是利用多道程序中的一道程序来模拟脱机输入时的外围控制机的功能，把低速\r\nI/O\r\n设备上的数据传送到高速磁盘上；用另一道程序来模拟脱机输出时外围控制机的功能，把数据从磁盘传送到低速输出设备上。这样，便在主机的直接控制下，实现脱机输入、输出功能。此时的外围操作与\r\nCPU 对数据的处理同时进行，这种在联机情况下实现的同时外围操作称为\r\nSPOOLing ，或称假脱机操作。\r\n\r\n\r\n优点\r\n\r\n提高了I/O速度。从对低速I/O设备进行的I/O操作变为对输入井或输出井的操作，如同脱机操作一样，提高了I/O速度，缓和了CPU与低速I/O设备速度不匹配的矛盾。\r\n将独占设备改造为共享设备。因为在SPOOLing系统的系统中，实际上并没为任何进程分配设备，而只是在输入井或输出井中为进程分配一个存储区和建立一张I/O请求表。这样，便把独占设备改造为共享设备。\r\n实现了虚拟设备功能。多个进程同时使用一独享设备，而对每一进程而言，都认为自己独占这一设备，从而实现了设备的虚拟分配。不过，该设备是逻辑上的设备\r\n\r\n\r\n\r\n案例\r\n\r\n将独享打印设备，变成多个程序共享的虚拟设备\r\n工作方法:\r\n系统对于用户的打印输出，但并不真正把打印机分配给该用户进程，而是先在输出井中申请一个空闲盘块区，并将要打印的数据送入其中；然后为用户申请并填写请求打印表，将该表挂到请求打印队列上。若打印机空闲，输出程序从请求打印队首取表，将要打印的数据从输出井传送到内存缓冲区，再进行打印，直到打印队列为空。\r\n\r\n现代操作系统类型\r\n分时系统\r\n概念\r\n分时主要指若干并发程序对CPU时间的共享\r\n优点\r\n响应快界面友好、多用户便于普及、便于资源共享\r\n与批处理多道程序设计的比较\r\n\r\n\r\n\r\n\r\n批处理多道程序设计\r\n分时系统\r\n\r\n\r\n\r\n\r\n设计目标\r\n充分使用处理器\r\n减少响应时间\r\n\r\n\r\n指令源\r\n作业控制语言，作业命令\r\n终端键入的命令\r\n\r\n\r\n\r\n基本特征\r\n\r\n\r\n多路性（Multiprogramming）\r\n\r\n     &lt;p&gt;系统能够同时处理多个任务，使得多个用户能够同时使用系统资源。每个任务都在独立的虚拟环境中运行，互不干扰。&lt;/p&gt;     &lt;/details&gt;          &lt;details&gt;         &lt;summary&gt;独立性（Independence）&lt;/summary&gt;         &lt;p&gt;每个用户的任务在系统中是相互独立的，彼此不会互相干扰或依赖。每个用户可以在系统中运行自己的程序，而不受其他用户程序的影响。&lt;/p&gt;     &lt;/details&gt;          &lt;details&gt;         &lt;summary&gt;交互性（Interactivity）&lt;/summary&gt;         &lt;p&gt;用户能够与系统进行实时的交互操作。他们可以通过终端或其他输入设备输入命令、请求数据，系统能够及时响应并返回结果给用户。&lt;/p&gt;     &lt;/details&gt;          &lt;details&gt;         &lt;summary&gt;及时性（Timeliness）&lt;/summary&gt;         &lt;p&gt;系统能够在合理的时间内响应用户的请求和任务，保证系统资源的有效利用和用户体验的流畅性。响应时间应该足够快，以便用户感觉不到延迟。&lt;/p&gt;     &lt;/details&gt;\r\n==实时系统==\r\n特点：\r\n响应时间很快、可以在毫秒甚至微秒，在限定时间内响应\r\n应用：\r\n过程控制系统、信息查询系统、事务处理系统\r\n分类：\r\n\r\n硬实时系统\r\n软实时系统\r\n\r\n与分时系统区别：\r\n交互能力较弱，系统专用，响应时间更严格，及时可靠性要求更高\r\n微机操作系统\r\n单用户系统\r\n资源独享，不支持批处理、多任务、多道程序设计\r\n用于工作站的系统\r\n\r\n单用户使用\r\n支持多道程序设计\r\n\r\n用于服务器的系统\r\n\r\n支持多用户\r\n支持多道程序设计\r\n实例：Unix以及微软的所有系统\r\n\r\n多处理机系统\r\n\r\n由于受电磁技术的限制，单处理机系统速度受到限制，因此，需要多处理机系统\r\n\r\n分类\r\n\r\n主从式\r\n对称式\r\n\r\n\r\n\r\n多处理机系统概述\r\n\r\n\r\n多处理机系统可以根据架构的不同分为对称式多处理机（SMP）和主从式多处理机两种：\r\n\r\n\r\n对称式多处理机（SMP）：所有处理器共享同一主存储器，每个处理器都可以访问共享的主存储器和I/O设备。处理器具有相同的权限和能力，可以独立执行任务，并通过共享总线或交叉开关进行通信。\r\n\r\n\r\n主从式多处理机：有一个或多个主处理器负责调度和协调系统中的其他从处理器。主处理器负责分配任务和资源，从处理器执行指定的计算任务，通常只能访问局部内存。\r\n\r\n\r\n选择适当的多处理机架构取决于应用的性能需求、系统复杂性和成本考量。\r\n\r\n\r\n网络操作系统\r\n\r\n网络操作系统是在各种各样自治的计算机原有操作系统基础上，加上具有网络访问功能的模块形成的。这些模块使网络上的计算机能方便、有效地共享网络资源，实现各种通信服务的有关协议。\r\n网络操作系统不是一个集中、统一的操作系统。\r\n\r\n特征：\r\n分布性、自治性、互连性、可见性\r\n\r\n\r\n网络操作系统特点\r\n\r\n\r\n分布性：网络操作系统能够管理和协调分布在不同网络节点上的资源和服务，使得这些资源和服务可以在整个网络中共享和访问。\r\n\r\n\r\n自治性：网络操作系统中的每个节点都可以独立运行和管理自身的资源，具有自主的操作和处理能力。\r\n\r\n\r\n互连性：网络操作系统通过网络协议和通信机制连接不同的节点，使得它们可以进行数据交换和协同工作，形成一个统一的系统。\r\n\r\n\r\n可见性：网络操作系统提供了对网络中资源和服务的可见性，使得用户和应用程序可以发现、访问和利用网络中的各种资源。\r\n\r\n\r\n分布式操作系统\r\n概念\r\n\r\n多计算机系统：地理位置不同，软硬件资源不同\r\n具有一个统一的操作系统：分配子任务，调度，管理资源，对用户透明\r\n\r\n特征\r\n分布式处理、模块化结构、利用信息通信、实施整体控制\r\n\r\n\r\n分布式系统特征\r\n\r\n\r\n分布式处理：分布式系统中的任务可以分布在多个节点或处理器上并行执行，从而提高系统的整体处理能力和效率。\r\n\r\n\r\n模块化结构：系统由多个相互独立的模块组成，每个模块负责不同的功能或服务，模块之间通过定义良好的接口进行通信和协作。\r\n\r\n\r\n利用信息通信：节点之间通过网络通信来进行数据传输和信息交换，实现节点之间的协调和合作。\r\n\r\n\r\n实施整体控制：尽管系统由多个分布式节点组成，但需要通过统一的控制和调度机制来管理和协调整个系统的运行，保证系统的一致性和可靠性。\r\n\r\n\r\n特点\r\n透明性、灵活性、可靠性、高性能、可扩充性\r\n\r\n\r\n分布式系统特点\r\n\r\n\r\n透明性：分布式系统隐藏了系统的分布性和复杂性，使得用户和应用程序可以像访问本地系统一样访问分布式系统的资源和服务。\r\n\r\n\r\n灵活性：分布式系统可以根据需求动态分配和管理资源，支持不同的应用程序和服务，并能够快速响应变化和增加新的节点。\r\n\r\n\r\n可靠性：分布式系统通过冗余和容错机制提高系统的可靠性，即使部分节点或资源出现故障，系统仍能保持正常运行。\r\n\r\n\r\n高性能：分布式系统利用并行处理和分布式计算能力，提高系统的整体性能和处理能力，能够处理大规模数据和复杂任务。\r\n\r\n\r\n可扩充性：分布式系统可以通过增加节点或资源来扩展系统的容量和性能，支持应对增加的用户请求和数据处理需求。\r\n\r\n\r\n操作系统的功能\r\n处理机管理（进程调度）\r\n原因\r\n在一段时间内，只能有一个进程在CPU中执行\r\n基本功能\r\n\r\n作业和进程调度\r\n进程控制\r\n进程通信\r\n\r\n\r\n同步方式和互斥方式；通信机制\r\n\r\n存储管理\r\n考虑因素\r\n\r\n速度\r\n大小\r\n成本\r\n\r\n基本功能\r\n\r\n内存分配\r\n地址映射（逻辑地址、物理地址）\r\n内存保护（上界地址值、下界地址值）\r\n内存扩充（虚拟存储技术）\r\n\r\n设备管理\r\n原因\r\n计算机外设种类众多，而且各种设备的传输速度差异很大，很难开发一种通用的、一致的解决方案。\r\n基本功能\r\n\r\n缓冲区管理\r\n设备分配\r\n设备驱动\r\n设备无关性\r\n\r\n文件管理\r\n\r\n在大多数应用中,文件是一个核心成分,除了实时应用和一些特殊应用外,应用程序的输入都是通过文件来实现的\r\n\r\n基本功能\r\n\r\n文件存储空间的管理\r\n文件操作的一般管理\r\n目录管理\r\n文件的读写管理\r\n存取控制\r\n\r\n附加功能服务\r\n用户硬件接口:基本类型\r\n\r\n命令界面(DOS, Unix, windows命令行)\r\n程序界面(系统调用界面)\r\n图形界面(windows窗口, Linux的X-window)\r\n\r\n网络\r\nTCP/IP…\r\n系统工具\r\n\r\nshell: command line interface, ls, find/search,man\r\n系统管理: ps,shutdown,mount,mkdir\r\n软件开发: compilers, debuggers\r\n\r\nOS 库\r\n\r\nI/O: data buffering and formatting\r\nMath: common utilities, APIs: (cos,sin,abs,sqrt)\r\n\r\n信息保护与安全\r\n\r\n访问控制\r\n\r\n只有经过授权的用户才能访问系统用户\r\n只能访问属于自己的信息\r\n\r\n信息流\r\n\r\n限制系统中的信息流动方向\r\n\r\n\r\n关于UNIX和windows\r\n\r\nSVR4是传统和现代版本的分水岭\r\n传统unix结构\r\n\r\n\r\n\r\nWindows系统的特点：微内核结构、客户服务器模型、支持线程、SMP、面向对象\r\nSolaris：可以在一个单独的Solaris内核实例中运行创建并管理多个虚拟化的操作系统，支持网际协议版本6（IPv6)，基于角色的访问控制（RBAC），支持32位的Intel\r\nx86\r\nmacOS：基于FreeBSD系统采用“面向对象操作系统”的全面的操作系统\r\n\r\n内存管理\r\n存储管理技术\r\n\r\n单一连续区\r\n固定分区\r\n\r\n大小相同\r\n大小不同\r\n\r\n可变分区\r\n\r\n怎么管理：空闲分区表\r\n\r\n\r\n固定分区地址映射\r\n\r\n固定定位\r\n静态重定位\r\n动态重定位\r\n\r\n可变分区分配算法\r\n\r\n首次适配\r\n\r\n对应回收算法\r\n\r\n循环首次适应算法\r\n最佳适配\r\n最差适配\r\n伙伴系统\r\n\r\n内存扩充技术\r\n\r\n覆盖\r\n交换技术\r\n多重分区\r\n\r\n简单分页\r\n\r\n\r\n文件系统\r\n磁盘结构和调度\r\n磁盘结构\r\n\r\n控制器通过移动臂移动磁头读写磁道上的数据。每面都有独立的磁头\r\n柱面: 所有盘片上的相同磁道组成柱面\r\n\r\n磁盘时延\r\n\r\n\r\n具体计算\r\n\r\n\r\n\r\n\r\n磁道优化\r\n\r\n\r\n优化方案\r\n\r\n\r\n\r\n所有磁道上的BPI 相同(“固定位密度”)\r\n\r\n\r\n磁盘容量更大\r\n\r\n\r\n越靠外圈的磁道包含的扇区越多\r\n\r\n\r\n磁盘转速固定，外磁道的速度比内磁道\r\n\r\n\r\n\r\n\r\n硬盘的使用\r\n\r\n硬盘必须分区\r\n分区需用某种文件系统进行格式化\r\n在某些情况下，可以用快速格式化取代完全格式化\r\n为什么需要多分区\r\n磁盘分布\r\nMBR（位置）、4个主分区、多个逻辑分区\r\n\r\n减少时延的方法：\r\n\r\n缓存/\r\n使用RAM磁盘/\r\nRAID/\r\n调度算法(读写头调度-&gt;调动磁头、元信息布置-&gt;怎么储存布置文件块)\r\n\r\n高速缓存\r\n\r\n\r\n\r\n关于高速缓存\r\n\r\n\r\n\r\n\r\n替换策略：\r\n\r\nLRU\r\nLFU\r\n基于频率的替换算法\r\n优点：弱化集中访问对计数器的影响\r\n具体实现：栈，计数器，新老两个区\r\n\r\n存在问题：新加入的块，如果很快进入老区，则没有竞争力，将很快被淘汰。\r\n\r\n磁盘调度\r\n\r\n作用\r\n\r\n提高有效的数据吞吐率\r\n减少请求的平均等待时间\r\n\r\n总结图\r\n\r\n\r\n\r\n 常用调度策略\r\nFCFS\r\n\r\n按请求的时间顺序，依次进行服务\r\n\r\n优点：\r\n\r\n实现简单\r\n有大量进程竞争时，在性能上接近于随机调度\r\n\r\n缺点\r\n\r\n寻道时间长，磁头移动幅度大\r\n\r\n适合较轻负载的系统\r\n\r\nSSTF最短寻道时间优先\r\n\r\n优先响应寻道时间最短的请求\r\n\r\n优点\r\n\r\n寻道时间较短，服务效率较高，服务平均等待时间较短\r\n提供比FIFO更高的效率\r\n\r\n缺点\r\n\r\n公平性差，可能会出现服务请求长期得不到服务，甚至饿死\r\n寻道时间并不能真正实现最优。\r\n\r\n适合中度负载的系统\r\n\r\nSCAN（电梯）算法\r\n\r\n磁头从一端出发向另一端移动，移动过程中，发现有请求对应磁头下的磁道，就对该请求提供服务。到另一端后，开始反向移动，遇到请求进行服务\r\n\r\n缺点：\r\n\r\n每个请求的等待时间不均匀，且平均等待时间长\r\n\r\n优化\r\n\r\n磁头并不是每次扫描都移动到最远的磁道上，一旦在当前方向上前面没有请求，就开始反向移动。\r\n\r\n比较适合磁盘负载较重的系统\r\n\r\nC-SCAN\r\n\r\n类似电梯算法。但需要从零道开始。\r\n磁头移动方向单一（从内到外）\r\n\r\nPRI进程优先级\r\nLIFO（后进先出）\r\n\r\n局部性最好，资源利用率最高（等待时间少、缓存命中高）\r\n\r\nN-step-scan\r\n\r\n把请求分为长度为N的多个队列；一次处理一个队列；新到的请求加到其他队列中。\r\n特性：N较大时，等价于SCAN；N=1时，等价于FIFO\r\n\r\nFSCAN\r\n\r\n如何评价各个磁盘调度\r\n\r\n通常情况下，除非有很多请求在队列中，否则，各个算法没太大区别\r\n操作系统可以以执行效率为目的来按一定的策略放置文件\r\n\r\n分布式系统把频繁使用的文件放在磁盘的中间位置\r\nExt2文件系统把inode节点放在磁盘靠近他们所表示的数据块的附近。\r\n\r\n\r\nRAID\r\n\r\n作用\r\n\r\n通过并行提高性能\r\n通过冗余提高可靠性\r\n\r\n\r\n常用层次：RAID0,RAID1.RAID 5,RAID6\r\n\r\n磁盘调度器（Linux）\r\n电梯调度器(Elevator)\r\n\r\n使用电梯算法：队列以块号进行排序\r\n\r\n\r\n有一个新的读写请求到达时，会依次考虑4个操作\r\n\r\n如果新请求与队列中的请求在同一磁盘扇区或相邻的扇区，则把新请求合并进队列\r\n如果队列中的请求已经很长时间了，则新请求将被插入到队列尾部\r\n如果有合适位置，则新请求将被按顺序插入队列中\r\n如果没有合适的位置，则新请求将被插入队列的尾部\r\n\r\n\r\n什么叫“请求已经很长时间了”\r\nLinux-时限IO调度器\r\n\r\n作用：为了防止Linux Elevator出现长期延迟问题\r\n采用3个队列：读请求同时存在于1，2队列中；写请求同时存在于1，3队列中\r\n\r\n\r\n\r\n读请求的默认时限是0.5秒，写请求5秒。\r\n\r\nLinux-预期IO调度器\r\n\r\n对时限IO调度器的改进\r\n根据“局部性”原理，磁盘请求往往相邻\r\n当读请求被分派时，预期调度器的执行将延迟6毫秒后再决定是否移动磁头到下一个位置\r\n\r\n文件系统基本信息\r\n早期不足\r\n\r\n\r\n自行展开\r\n\r\n\r\n\r\n\r\n而后由个人向系统级发展，以系统调用的形式向应用程序提供数据管理服务\r\n\r\n要求\r\n目标\r\n方便用户管理自己的数据资源\r\n基本要求\r\n\r\n文件按名存储\r\n文件有序组织，文件名分层次管理\r\n\r\n如支持树形目录结构\r\n\r\n操作简单，存取效率高。\r\n\r\n其他要求\r\n\r\n支持多用户系统，多用户能够共享同一个磁介质\r\n有一定的安全性保证，最好能进行数据恢复\r\n存储空间的利用率高\r\n\r\n基本概念\r\n\r\n文件：由文件名字标识的一组相关信息的集合。文件名是字母或数字组成的字母数字串\r\n文件系统:\r\n软件观点：操作系统中，为用户和应用程序管理文件的系统软件集合\r\n存储格式观点：文件系统是文件在存储介质上保存和管理相关的约定。在操作系统中，这种约定的实现也被称为文件系统。一种相关约定就对应一种文件系统，所以目前存在多种文件系统：FAT，FAT32，NTFS，EXT2等\r\n一个操作系统除支持为它设计的文件系统外，还可能支持其他文件系统\r\n\r\n文件的命名\r\n\r\n文件名是字母或数字组成的字母数字串，在一些文件系统中还可能包含其它字符，如下划线等\r\n各种文件系统的文件命名规则略有不同，即文件名的格式和长度因系统而异。\r\n\r\n\r\n长度包括文件路径\r\n\r\n文件的类型\r\n\r\n普通文件：即前面所讨论的存储在外存设备上的数据文件。\r\n目录文件：文件在管理普通数据文件时，需要保存其相应的文件和属性，这些属性以目录文件的形式存储在磁盘中。\r\n块设备文件：在unix/Linux等操作系统中，对应于磁盘、光盘或磁带等块设备的文件。\r\n字符设备文件：在unix/Linux等操作系统中，对应于终端、打印机等字符设备的文件\r\n\r\n文件的属性\r\n\r\n优点\r\n\r\n用户使用方便：只要知道文件名，可存取信息，实现了“按名存取”\r\n安全可靠性：\r\n用户通过文件系统才能实现对文件的访问，故可防止对文件信息无意的破坏。\r\n而文件系统能提供各种安全、保密和保护措施\r\n数据共享\r\n\r\n移动存储设备\r\n各种形式的文件链接，不同的用户可以使用同名或异名的同一文件\r\n\r\n\r\n设备管理\r\n如果没有设备管理会怎么样\r\n\r\n加重应用程序设计者的负担。\r\n应用程序的移植性比较差\r\n设备利用率低\r\n\r\n基本概念\r\n设备概念\r\n\r\n进行实际输入输出操作的物理设备\r\n控制物理设备的支持设备和支持部件\r\n为提高利用率，形成的逻辑设备和虚拟设备。\r\n\r\n\r\n用高级编程语言操作的是什么设备\r\n是逻辑设备哦\r\n\r\n分类\r\n外在功能\r\n输入设备 // 输出设备 // 存储设备 // 供电设备 // 网络设备......\r\n数据传输方式\r\n\r\n块设备\r\n字符设备\r\n流设备\r\n\r\n存在形式\r\n\r\n物理设备\r\n逻辑设备\r\n\r\n资源属性（OS管理）\r\n\r\n共享设备\r\n独占设备\r\n虚拟设备\r\n\r\n要求\r\n\r\n方便、统一的设备使用界面、\r\n提高外部设备利用率，尽量提高并行程度\r\n实现程序与设备的无关性\r\n\r\n功能\r\n\r\n设备的配置和资源分配\r\n设备的控制和驱动\r\n系统与设备之间的缓冲\r\n协调设备的调度和分配\r\n\r\n设备管理层次关系\r\n\r\n底层通信（中断处理）\r\n\r\n实现软件和硬件设备的通信\r\n\r\n设备驱动\r\n\r\n接受来自上层的抽象操作请求，并负责操作的具体实施\r\n主要组成：与设备打交道的软件、共享支持、缓冲区支持等\r\n\r\n对用户层的I/O接口\r\n\r\n每个I/O调用接口对应具体的设备抽象操作\r\n\r\n使用设备的用户级程序\r\n\r\n通过调用所提供的接口来实现对设备的使用或控制\r\n\r\n\r\n时钟中断\r\n\r\n硬件时钟：由硬件脉冲形成，经计数器和定时器产生定时中断。\r\n\r\n\r\n软件时钟：由程序模拟的时钟，可以产生软中断。\r\n\r\n分类\r\n\r\n系统时钟（软时钟）：控制指令执行\r\n日历时钟（由软件根据实时时钟设置）\r\n实时时钟 (Real-time clock):\r\n提醒处理器有其他事情要做（也就是产生硬件中断）\r\n\r\n系统时钟的维护\r\n在计算机没有启动时。主板上包含了一个类似石英钟的物理时钟在记录时间的流逝和变化\r\n系统启动时，OS从物理时钟读取当前时间，保存在全局变量里。时间度量单位为Tick。\r\n每过一个Tick（即一个计时单位，由操作系统定义），时钟芯片都会向CPU发送一个时钟中断。\r\n举例\r\n\r\n紧急任务（1个tick，例如1ms）：\r\n\r\n运行进程的优先级调整\r\n终端延时处理\r\n\r\n非紧急任务（例如，1秒）：\r\n\r\n非运行态进程的优先级调整\r\n\r\n\r\nOS控制IO操作\r\n硬件组成\r\n\r\n机械部件（实施部件）：具体实现设备的操作\r\n电子部件（接口部件）：又叫设备控制器\r\n\r\n直接外接用于控制和数据通信的电缆线\r\n操作系统与控制器直接打交道，发送操作命令，或收发数据\r\n控制器接收OS发来的操作指令，控制机械部件完成相应操作\r\n\r\n\r\n资源分配\r\nI/O地址\r\n\r\n设备内部的I/O编址：局限于单个设备\r\n整个系统I/O编址：需要把单个设备的I/O编址映射到系统全局编址\r\n\r\n与内存统一编址：同一般的内存访问操作\r\n与内存分开编址：需要使用专门的I/O指令访问设备控制器的寄存器\r\n\r\n\r\n\r\n在设备接入之后，需要分配合适的I/O地址。设备内部的I/O地址要映射到所分配的I/O地址上\r\n\r\nI/O中断请求\r\n\r\n中断控制器支持的中断数量有限，每个进行了编号\r\n设备接入系统后，需要分配中断号。一般情况下，多个设备不能共享同一中断号\r\n\r\n\r\n没有合适的中断编号设备就不能正常工作。\r\n\r\nDMA数据传输通道\r\n关于IO通道\r\n\r\nI/O通道是一种硬件设施，带有专用处理器的，是有很强I/O处理功能的智能部件\r\n可以独立地完成系统处理器交付的I/O操作任务，通道具有自己专门的指令集，即通道指令\r\n通道执行来自处理器的通道程序，完成后只需向系统处理器发出中断，请求结束\r\n\r\nIO通道分类\r\n\r\n字节多路通道\r\n\r\n用于连接大量低、中速的I/O设备，每次传输一个字节\r\n以字节为单位交叉地工作，当为一台设备传送一个字节后，立即转去为另一台设备传送一个字节\r\n\r\n选择通道\r\n\r\n用于支持高速设备（如磁盘），每次只与一个设备进行数据传输\r\n数据传输是以块为单位，每次可以传输一批数据\r\n每当一个输入输出操作请求完成后，再选择与通道相连接的另一设备\r\n\r\n成组多路通道\r\n\r\n以分时方式同时执行几道通道程序，分别实现与几个高速设备的数据传输\r\n实质是对通道程序采用多道程序设计技术的硬件实现\r\n。\r\n\r\n\r\nDMA传输通道\r\n\r\n内存和I/O设备之间的自动化数据通路，在主存和I/O设备之间成块传送数据过程中，不需要CPU干预，CPU资源的利用率再次得到提高\r\nDMA不仅设有中断机构，而且，还增加了DMA传输控制机构（类似于CPU)\r\n\r\nI/O缓冲区\r\n\r\n需求\r\n\r\n提高CPU和外设的并行度\r\n缓解外设速度慢的瓶颈\r\n\r\n分类\r\n\r\n硬件缓冲：有些设备中会包含专门的硬件寄存器等用于缓冲。\r\n软件缓冲：直接在主存中\r\n\r\n单缓冲：一个缓冲，外设和CPU互斥进行操作\r\n双缓冲：设置两个缓冲区，交替使用\r\n循环缓冲：类似于循环队列，依次使用\r\n缓冲池：系统维护一组大小相同的缓冲区，进程和设备按需要申请，使用完后重新归入缓冲池中\r\n\r\n\r\n\r\n资源控制\r\n使用设备控制表（DCT）控制设备。\r\n设备控制表（DCT）\r\n\r\n作用：将抽象的I/O操作映射到实际的设备\r\n记录内容：\r\n\r\n抽象设备描述\r\n实际设备地址\r\n驱动程序参数等\r\n\r\n\r\n]\r\n\r\n示例\r\n\r\n&lt;img src=&quot;https://raw.githubusercontent.com/sensuschung/wordpress_image/master/blog/202406050040213.png&quot; alt=&quot;image-20240605004011179&quot; style=&quot;zoom:80%;&quot; /&gt;\r\n\r\n\r\n设备开关表\r\n\r\n内容\r\n\r\n·设备号（对应于DCT中的设备号）\r\n打开设备的程序入口地址\r\n关闭设备的程序入口地址\r\n\r\n\r\n\r\nUnix设备的管理分配\r\n管理层次\r\n设备文件-&gt;设备开关表-&gt;驱动程序-&gt;I/O指令（控制寄存器）-&gt;硬件\r\n设备分配\r\n功能\r\n\r\n为进程或作业分配所需的设备\r\n充分发挥设备的使用效率，尽可能避免死锁\r\n\r\n分配方式\r\n\r\n静态分配：\r\n\r\n作业开始运行时，一次性分配给所有可能使用到的设备\r\n设备利用率低\r\n简单，不会出现死锁\r\n\r\n动态分配\r\n\r\n进程使用设备时再进行相应分配\r\n设备利用高，可能会出现死锁\r\n\r\n\r\n设备请求管理\r\n\r\n要使用设备时必须提供进行I/O操作的有关信息，指出执行I/O的逻辑设备名（如设备号）、操作类型、传送数据的数目、信息源或目的地址等。\r\n存放进行I/O操作的信息的结构称为\r\nI/O请求块 \r\n\r\n在UNIX系统中，系统的I/O请求块的内容是包含在缓冲区控制块buf中\r\n\r\n\r\n\r\n在请求I/O时，首先请求分配缓冲区，然后把与操作有关的信息写到buf中，并把这个buf挂到请求设备的I/O请求队列中去\r\n\r\n\r\n\r\n\r\n分配原则\r\n\r\n独占设备：同时只能分配给一个请求进程。\r\n共享设备：同时可以将一个设备分配给多个请求进程。\r\n虚拟设备：用一个逻辑设备来同时模拟多个独占设备，达到设备共享的目的，提高设备利用率。\r\n\r\n分配算法\r\n先请求先服务\r\n\r\n系统按先后次序组成I/O请求队列，每个设备一个队列\r\n当新的I/O请求块生成后，把该块挂在相应设备的I/O请求队列的队尾\r\n设备空闲时，从该设备的I/O请求队列的队首取出一个请求块，并按这个请求块的要求进行I/O操作\r\n\r\n按进程优先权确定服务次序\r\n\r\n系统按请求进程的优先级由高到低次序组成I/O请求队列，每个设备一个队列。（多队列）\r\n当新的I/O请求块生成后，根据请求优先级把该块挂在相应设备的I/O请求队列中的合适位置。\r\n设备空闲时，从该设备的I/O请求队列的队首取出一个请求块，并按这个请求块的要求进行I/O操作\r\n\r\n上层统一接口\r\n\r\n\r\n操作系统的设备管理需要隐藏设备的操作细节\r\n解决问题\r\n\r\n如何用统一的方式来标示设备\r\n如何用统一的方法来表示设备的不同操作\r\n\r\n\r\n\r\n实现思路\r\n\r\n操作系统对上提供若干高级I/O系统调用(getc,\r\nputc, read , write ,seek, open, close等)\r\n\r\n这些调用接口同普通文件的调用接口\r\nI/O系统调用对应抽象的I/O操作，包含对I/O设备的控制：请求、响应、处理控制、缓冲等\r\n对这些抽象I/O操作请求，不同的设备具有不同的理解，对应不同的设备动作\r\n\r\n通过抽象的I/O操作把应用程序与复杂的I/O设备控制隔离开来。\r\n\r\n设备的命名\r\n以文件名的形式来表示,这些文件叫设备文件\r\n把设备文件和对应的设备（或设备驱动程序）联系起来的是设备文件的两个属性:\r\n\r\n主设备号：通过主设备号就可以找到相应的设备驱动程序。同种类型的设备如果驱动相同，主设备号可以相同。\r\n次设备号：它作为传给驱动程序的参数指定具体的物理设备。\r\n\r\n缓冲区管理\r\n\r\n设置了多种队列对所有缓冲区进行管理\r\n因为buf记录了与缓冲区有关的各种管理信息，所以缓冲区管理队列实际上是缓存控制块buf队列。\r\n\r\n缓冲控制块buf\r\n存储缓冲区信息、IO请求、执行结果\r\nbuf队列\r\n\r\n自由（空闲）buf 队列：FIFO\r\n设备缓冲区队列：双向队列；被分配用于读、写某个设备的字符块\r\n空设备队列（NODEV队列）：特殊设备/无对应的实际设备（只有对应的特殊内容）\r\n\r\n为程序传递参数\r\n存放文件系统的资源管理块\r\n\r\n\r\n\r\n系统初始化时会把所有的空间缓冲区buf同时放在自由buf和NODEV上\r\n\r\n\r\n设备I/O请求队列：每个块设备有一个I/O请求队列（iobuf，单向连接）\r\n\r\n==缓冲区之间关系==\r\n\r\n管理算法\r\n采用LRU算法\r\n\r\n一个缓存刚分配用于读写某一块设备，buf的b_flags含有B_BUSY标志。它一定位于相应设备buf队列，不在自由队列。\r\n一旦读写完成，就释放缓存，清B_BUSY标志。送入自由队列尾，但仍留在原设备队列。\r\n\r\n优点：\r\n\r\n避免了重复I/O：只要还要重复使用原设备队列中该缓存内容，就只要简单地将其从自由队列抽出即可\r\n实现延迟写:实现了异步延迟写机制\r\n\r\n字符设备管理\r\n\r\n需要两个寄存器\r\n\r\n控制状态寄存器\r\n数据缓冲寄存器\r\n\r\n作为一个特殊文件来处理\r\n数据流与控制流\r\n\r\n\r\n\r\n缓冲区非常小；三种队列：原始（读入）、规范（转换）、输出（写出）\r\n\r\nLinux设备管理\r\n\r\n接口管理\r\n\r\n每台设备用一个特殊设备文件来表示。/dev/hda表示第一个磁盘，/dev/hda1表示第一个磁盘的第一个分区。（device）\r\n通过访问文件的接口就能实现对设备的访问。\r\n\r\n驱动程序\r\n\r\n运行在核心态\r\n对应用层提供标准接口\r\n灵活性\r\n\r\n可配置，可以通过配置选择特定的驱动程序编译到内核中。\r\n也可以编译成模块，实现动态加载\r\n\r\n\r\n字符设备\r\n\r\n字符设备矢量表\r\n\r\n每一项对应一个设备。每一项的信息包含设备控制块指针，以及各种抽象操作的实现函数\r\n\r\n虚拟文件系统\r\n\r\n能够实现文件操作到实现函数的映射\r\n\r\n\r\n块设备\r\n\r\n与字符设备的相同点\r\n\r\n对上提供文件操作类似的接口\r\n存在与字符设备矢量表功能类似的块设备矢量表\r\n\r\n与字符设备的差别\r\n\r\n与高速缓冲区间存在接口\r\n需要管理相应的队列。\r\n\r\n\r\n网络\r\n\r\n网络设备是发送和接收数据包的实体。\r\n通常对应于网卡\r\n\r\n遗留作业\r\n概论\r\nSpooling和内存缓冲技术的区别\r\nSpooling（Simultaneous Peripheral Operations\r\nOn-Line）和内存缓冲技术是用来提高计算机系统性能的两种不同技术：\r\n\r\nSpooling：\r\n\r\n定义：Spooling\r\n是一种技术，它允许计算机在执行多个任务时，将这些任务的输入和输出数据暂时存储在磁盘或其他介质上，而不是直接在主内存中处理。\r\n作用：通过将输入/输出数据缓冲到磁盘上的临时存储区域，系统可以更高效地管理多个任务的输入输出，避免了需要等待长时间的磁盘访问操作。\r\n\r\n内存缓冲技术：\r\n\r\n定义：内存缓冲技术是一种通过使用计算机内存中的缓冲区来存储数据，从而改善数据传输和处理效率的技术。\r\n作用：内存缓冲可以在数据传输和处理过程中，暂时存储数据，减少因为数据传输速度不匹配而导致的等待时间，提高系统性能和响应速度。\r\n\r\n\r\n区别： - 存储位置：Spooling\r\n将数据存储在磁盘或其他非易失性介质上，而内存缓冲技术将数据存储在计算机内存中。\r\n- 使用场景：Spooling\r\n主要用于管理和调度多个任务的输入输出，而内存缓冲技术更多用于优化数据传输和处理效率。\r\n- 实现方式：Spooling\r\n通常需要特定的操作系统支持和软件实现，而内存缓冲可以通过应用程序或操作系统本身实现。\r\n总之，这两种技术都旨在提高计算机系统的效率和响应速度，但它们的应用场景和实现方式有所不同。\r\nSpooling和内存缓冲技术的区别\r\nSpooling（假脱机）和真正的脱机技术是计算机领域中两种不同的数据处理和管理方式：\r\n\r\nSpooling（假脱机）：\r\n\r\n定义：Spooling\r\n是一种技术，它允许计算机系统将任务的输入和输出数据暂时存储在磁盘或其他介质上，而不是直接在主内存中处理。这种方式使得系统可以并行处理多个任务的输入输出，而不会因为等待磁盘访问而导致性能下降。\r\n特点：Spooling\r\n本质上是一种虚拟的脱机操作，因为它并不真正将数据传输到物理脱机设备上，而是将数据缓存到临时存储区域（如磁盘）以便后续处理。\r\n\r\n真正的脱机技术：\r\n\r\n定义：真正的脱机技术涉及将数据完全从计算机系统中取出，并通过物理介质（如磁带或光盘）存储到脱机设备中，然后在需要时再将数据取回计算机系统进行处理。\r\n特点：脱机技术通常用于大规模数据存储和备份，它可以有效地释放计算机系统的资源，因为数据不需要在系统活动时持续占用内存或处理器。\r\n\r\n\r\n区别： - 操作对象：Spooling\r\n是针对任务的输入输出数据进行缓冲和管理，而真正的脱机技术则是针对大量数据的物理存储和处理。\r\n- 存储介质：Spooling\r\n使用磁盘等非易失性存储介质作为缓冲区，而脱机技术使用磁带、光盘等物理介质作为数据的永久存储。\r\n- 应用场景：Spooling\r\n主要用于多任务并发处理的输入输出优化，而脱机技术则更多用于数据备份、长期存储和数据迁移等大规模数据处理场景。\r\n总结来说，Spooling\r\n是一种虚拟的脱机操作技术，通过缓冲数据到磁盘上来提高系统效率；而真正的脱机技术则是实际将数据存储到物理脱机设备上，用于长期存储和备份。\r\nUnix系统的基本结构分为哪几层\r\n\r\n\r\nUnix系统的基本结构\r\n\r\n\r\n硬件层：\r\n包括计算机的物理硬件，如CPU、内存、磁盘驱动器、网络接口等。它是Unix系统赖以运行的基础。\r\n\r\n\r\n内核层：\r\n内核是Unix系统的核心部分，负责管理硬件资源，并为上层软件提供服务。内核主要功能包括进程管理、内存管理、文件系统管理、设备驱动、系统调用接口等。\r\n\r\n\r\n系统调用接口层： 系统调用接口（System Call Interface,\r\nSCI）是用户进程和内核之间的桥梁。它提供一组标准的接口，允许用户进程请求内核服务，如文件操作、进程控制、内存分配等。\r\n\r\n\r\n库函数层：\r\n库函数层由标准C库（libc）等组成，提供常用的编程接口和工具函数。库函数通常封装系统调用，简化应用程序开发。\r\n\r\n\r\n用户命令和应用程序层：\r\n包括各种用户命令、系统管理工具和应用程序。这一层直接与用户交互，为用户提供功能强大的操作和管理工具。常见的用户命令有ls、cp、mv等。\r\n\r\n\r\n用户层：\r\n用户层是Unix系统的最外层，包括最终用户和系统管理员，他们通过命令行界面（CLI）或图形用户界面（GUI）与系统交互。\r\n\r\n\r\n磁盘调度\r\n\r\n磁盘调度\r\n\r\n\r\n\r\n\r\n\r\n","slug":"NIS2334","date":"2024-06-02T14:16:00.000Z","categories_index":"study,class","tags_index":"review,2023-2024Spring,OS","author_index":"sensuschung"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very\r\nfirst post. Check documentation for\r\nmore info. If you get any problems when using Hexo, you can find the\r\nanswer in troubleshooting or\r\nyou can ask me on GitHub.\r\nQuick Start\r\nCreate a new post\r\n1$ hexo new &quot;My New Post&quot;\r\nMore info: Writing\r\nRun server\r\n1$ hexo server\r\nMore info: Server\r\nGenerate static files\r\n1$ hexo generate\r\nMore info: Generating\r\nDeploy to remote sites\r\n1$ hexo deploy\r\nMore info: Deployment\r\n","slug":"hello-world","date":"2024-05-26T02:19:19.000Z","categories_index":"others","tags_index":"test","author_index":"sensuschung"}]